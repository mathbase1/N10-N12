

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GCSE Maths (Foundation) — Number Topic Preview (N10–N12)</title>
<style>
  /* SECTION: Styles
     - Layout + typography
     - Question card UI
     - Input widgets (including drag-and-drop ordering and standard form EXP entry)
     NOTE: Keep classnames/IDs stable: the JS relies on many of them.
  */
  :root{
    --ink:#0f172a; --muted:#6b7280; --accent:#2563eb; --bg:#ffffff; --border:#e5e7eb;
    --green:#16a34a; --orange:#f59e0b; --red:#dc2626;
    --fbar:1px; /* ultra-thin fraction bar */
  }

  html,body{
    margin:0;padding:0;background:var(--bg);color:var(--ink);
    font:19px/1.65 system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans",sans-serif;
  }

  header{position:sticky;top:0;z-index:50;background:#fff;border-bottom:1px solid var(--border)}
  main{max-width:1040px;margin:1.2rem auto 4rem;padding:0 1rem}

  /* top control bar (simple, no tabs) */
  .bar{
    display:flex;gap:.65rem;align-items:center;flex-wrap:wrap;
    padding:.75rem .9rem
  }
  .bar .group{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .bar label{font-weight:900;color:#111827;font-size:1rem}
  select, input[type="text"], input[type="number"]{
    padding:.55rem .65rem;border:1px solid var(--border);border-radius:.6rem;min-width:160px;
    background:#fff;color:var(--ink);font-size:1rem
  }
  input[type="text"], input[type="number"]{min-width:160px}
  .primary{
    background:var(--accent);color:#fff;border:1px solid var(--accent);
    border-radius:.65rem;padding:.6rem 1.05rem;cursor:pointer;font-weight:900;font-size:1rem
  }
  .ghost{
    background:#fff;color:var(--ink);border:1px solid var(--border);
    border-radius:.65rem;padding:.6rem 1.05rem;cursor:pointer;font-weight:900;font-size:1rem
  }
  .muted{color:var(--muted);font-size:1rem}
  .spacer{flex:1}
  .actions{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap}

  /* question panel */
  .qpanel{border:1px solid var(--border);border-radius:1rem;overflow:hidden;margin-top:1rem;
    box-shadow:0 1px 0 rgba(0,0,0,.03)}
  .qhead{
    padding:1rem 1.05rem;border-bottom:1px solid var(--border);
    background:linear-gradient(180deg,#fbfdff,#f8fafc);
    display:flex;align-items:center;justify-content:space-between;gap:.7rem;flex-wrap:wrap
  }
  .qhead h3{margin:.1rem 0;font-size:1.2rem}
  .qbody{padding:1.1rem 1.05rem}
  .badge{display:inline-block;margin-left:.55rem;padding:.08rem .5rem;border:1px solid var(--border);
    border-radius:8px;background:#eef2ff;font-size:.95rem}
  .nc-tag{font-weight:900;text-transform:uppercase;letter-spacing:.02em;font-size:.95rem}
  .nc{color:#15803d}
  .calc{color:#1d4ed8}

  /* question lines */
  .item{padding:.6rem .1rem;border-bottom:1px dashed rgba(229,231,235,.9)}
  .item:last-child{border-bottom:none}
  .line{
    display:flex;align-items:flex-start;gap:.75rem;flex-wrap:wrap;
  }
  .qtext{flex:1;min-width:280px}
  .endmark{margin-left:.4rem;font-weight:900;color:#334155}

  .hlDigit{background:rgba(245,158,11,.25);border:1px solid rgba(245,158,11,.45);border-radius:.25rem;padding:0 .2rem;box-decoration-break:clone;-webkit-box-decoration-break:clone;}
  .sfhint{font-size:.85rem;color:#64748b;margin-top:.35rem;max-width:520px}

  /* inputs - feedback highlighting */
  .ok{outline:2px solid rgba(22,163,74,.35); border-color:rgba(22,163,74,.55)!important}
  .bad{outline:2px solid rgba(220,38,38,.28); border-color:rgba(220,38,38,.55)!important}

  /* fraction widget */
  .frac{display:inline-grid;grid-template-rows:auto 0 auto;row-gap:0;align-items:center;justify-items:center;line-height:0;vertical-align:middle}
  .frac input{
    width:92px;text-align:center;border:1px solid var(--border);border-radius:.45rem;padding:.45rem .5rem;margin:0;
    appearance:textfield;font-size:1rem;min-width:0
  }
  .frac input::-webkit-outer-spin-button,.frac input::-webkit-inner-spin-button{appearance:none;margin:0}
  .frac .bar{width:92px;height:0;border-top:var(--fbar) solid #111;margin:16px 0 0 0}
  .frac input:last-child{margin-top:-2px}

  /* pair/triple widgets */
  .twobox, .threebox, .sfbox{
    display:inline-flex;gap:.5rem;align-items:center;flex-wrap:wrap
  }
  .twobox input, .threebox input, .sfbox input{
    min-width:120px
  }
  .mini{min-width:110px!important}
  .tiny{min-width:90px!important}


  /* standard form input (no ^) */
  .sfTen{font-weight:900}
  .sfexp{
    vertical-align:super;
    font-size:.85rem;
    min-width:72px!important;
    width:72px;
    padding:.22rem .3rem;
  }

  /* prime factorisation input (EXP toggles superscripts) */
  .pfbox{
    min-height:44px;
    border:1px solid var(--border);
    border-radius:.55rem;
    padding:.45rem .55rem;
    background:#fff;
    font-weight:850;
    letter-spacing:.01em;
    line-height:1.2;
  }
  .pfbox sup{font-size:.75em;vertical-align:super}
  .pfbox .mul{opacity:.9;padding:0 .12rem}
  .kbtn.on{
    background:#2563eb;
    border-color:#2563eb;
    color:#fff;
  }

  /* prime factors keypad */
  .pfwrap{display:flex;flex-direction:column;gap:.5rem;min-width:320px}
  .keypad{display:flex;gap:.45rem;flex-wrap:wrap}
  .kbtn{
    border:1px solid var(--border);background:#fff;border-radius:.6rem;
    padding:.4rem .7rem;cursor:pointer;font-weight:900;font-size:1rem
  }
  .kbtn:active{transform:translateY(1px)}
  .kbtn.accent{border-color:rgba(37,99,235,.35);background:#eef2ff}

  /* feedback */
  .feedback{margin-top:1rem;border:1px solid var(--border);border-radius:.75rem;padding:.85rem 1rem;background:#f8fafc}
  .feedback.good{background:#ecfdf5;border-color:rgba(22,163,74,.22);color:#065f46}
  .feedback.bad{background:#fef2f2;border-color:rgba(220,38,38,.22);color:#7f1d1d}

  .mathwrap{display:inline-block;vertical-align:middle}
  .mathwrap math{font-size:calc(1em + 5px);}

  /* -------------------- N10: Work-out layout (text line then MathML line) -------------------- */
  .wo-block{margin:.15rem 0;}
  .wo-text{margin:.12rem 0;}
  .wo-row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:.75rem;
    flex-wrap:wrap;
    margin:.2rem 0;
  }
  .wo-math{display:block;}
  .wo-ans{display:flex;justify-content:flex-end;align-items:center;}


  /* -------------------- drag ordering widget -------------------- */
  .drag-order{
    margin:.6rem 0 .1rem 0;
    padding:.6rem .65rem;
    border:1px solid var(--border);
    border-radius:1rem;
    background:linear-gradient(180deg,#ffffff,#f8fafc);
  }
  .drag-bank, .drag-targets{
    display:flex;
    gap:.5rem;
    flex-wrap:wrap;
    align-items:center;
  }
  .drag-bank{
    padding:.5rem;
    border:1px solid var(--border);
    border-radius:.85rem;
    background:#fff;
  }
  .drag-targets{
    margin-top:.55rem;
    padding:.5rem;
    border:1px dashed rgba(107,114,128,.35);
    border-radius:.85rem;
    background:#f8fafc;
    min-height:56px;
  }
  .dragbox{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:.35rem .65rem;
    border:1px solid var(--border);
    border-radius:.7rem;
    background:#fff;
    cursor:grab;
    font-weight:900;
    user-select:none;
    -webkit-user-select:none;
    touch-action:manipulation;
  }
  .dragbox:active{ cursor:grabbing; }
  .dragbox.dragging{ opacity:.55; }
  .dragbox.selected{
    outline:2px solid rgba(37,99,235,.45);
    border-color:rgba(37,99,235,.55);
  }
  .dropbox{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    min-width:92px;
    min-height:46px;
    padding:.2rem .35rem;
    border:2px dashed rgba(229,231,235,.95);
    border-radius:.7rem;
    background:#fff;
  }
  .dropbox.over{
    border-color:rgba(37,99,235,.65);
    background:#eff6ff;
  }
  .dropbox .dragbox{ cursor:grab; }

  .drag-instr{
    margin-top:.45rem;
    color:var(--muted);
    font-size:1rem;
  }

  .dragbox math{ font-size:1.05em; }

  /* -------------------- standard form (single box + EXP keypad) -------------------- */
  .sfwrap{
    display:flex;
    flex-direction:column;
    gap:.55rem;
    min-width:320px;
  }
  .sfinput{
    padding:.55rem .65rem;
    border:1px solid var(--border);
    border-radius:.6rem;
    background:#fff;
    color:var(--ink);
    font-size:1rem;
    min-width:240px;
  }
  .sfhint{
    color:var(--muted);
    font-size:1rem;
  }


  /* -------------------- tables (used in N10 4–5 mark questions) -------------------- */
  .valtable{
    border-collapse:collapse;
    margin:.55rem 0 .75rem 0;
    width:100%;
    max-width:520px;
    font-size:1rem;
  }
  .valtable th, .valtable td{
    border:1px solid var(--border);
    padding:.35rem .55rem;
    text-align:left;
  }
  .valtable th{
    background:#f1f5f9;
    font-weight:900;
  }
  .valtable th:last-child, .valtable td:last-child{
    text-align:right;
    font-variant-numeric: tabular-nums;
  }

  @media (max-width:560px){
    .dropbox{ min-width:78px; }
    .sfwrap{ min-width:260px; }
  }

</style>
</head>
<body>

<header>
  <div class="bar">
    <div class="group">
      <label for="topicSel">Topic</label>
      <select id="topicSel"></select>
    </div>

    <div class="group">
      <label for="marksSel">Marks</label>
      <select id="marksSel">
        <option value="1">1 mark</option>
        <option value="2">2 marks</option>
        <option value="3">3 marks</option>
        <option value="4">4 marks</option>
        <option value="5">5 marks</option>
      </select>
    </div>

    <div class="group">
      <label for="calcSel">Paper</label>
      <select id="calcSel">
        <option value="noncalc">Non-calculator</option>
        <option value="calc">Calculator</option>
      </select>
    </div>

    <div class="spacer"></div>

    <div class="actions">
      <button class="primary" id="regenBtn" type="button">Regenerate numbers</button>
      <button class="ghost" id="checkBtn" type="button">Check</button>
      <button class="ghost" id="revealBtn" type="button">Reveal answers</button>
    </div>
  </div>
</header>

<main>
  <section id="preview"></section>
  <div class="feedback" id="fb" style="display:none"></div>
</main>

<script>
/* ============================================================
   GCSE (Foundation) Number Question Preview Tool (N1–N50)
   - NO ratio topics.
   - NO recurring decimals.
   - Finer-grained topics (each N code is a single narrow topic).
   - Marks selector gives a question that is worth those marks:
       higher marks => more steps / more answer boxes / more structure,
       not just “same question with bigger numbers”.
   - Calculator mode uses calculator-suitable numbers (messier decimals, awkward divisions),
     and where needed asks for answers to 2 decimal places.
   ============================================================ */

// SECTION: File map (searchable)
// - SECTION: Seeded RNG
// - SECTION: Formatting helpers (MathML, standard form parsing)
// - SECTION: Topic list / navigation (TOPICS)
// - SECTION: Scenario variants (contextVariants)
// - SECTION: Question parts (partInteger/partNumber/...)
// - SECTION: Build question card (buildQuestion switch by topic code)
// - SECTION: Rendering + interaction (tabs, check/reveal, drag ordering)
// EDIT HERE: Most question content is generated in buildQuestion(topicCode, marksTotal, rng).

// SECTION: Seeded RNG (deterministic per regeneration seed)
function hashToUint32(str){
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
function cryptoSeed(){
  if (window.crypto && crypto.getRandomValues){
    const a = new Uint32Array(1);
    crypto.getRandomValues(a);
    return a[0] >>> 0;
  }
  return (Math.random()*2**32)>>>0;
}
function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let x = t;
    x = Math.imul(x ^ (x >>> 15), x | 1);
    x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}
function makeRng(seedLike){
  const seed = (seedLike===undefined || seedLike===null || seedLike==="")
    ? cryptoSeed()
    : (typeof seedLike==="number" ? (seedLike>>>0) : hashToUint32(String(seedLike)));
  const r = mulberry32(seed);
  return {
    seed,
    float: ()=>r(),
    int: (min,max)=>{
      min=Math.ceil(min); max=Math.floor(max);
      return Math.floor(r()*(max-min+1))+min;
    },
    choice: (arr)=>arr[Math.floor(r()*arr.length)],
    shuffle: (arr)=>{
      const a=arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j=Math.floor(r()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }
  };
}

/* -------------------- helpers -------------------- */
function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){[a,b]=[b,a%b]}return a||1}
function lcm(a,b){ return Math.abs(a*b)/gcd(a,b); }
function roundTo(x, dp){
  const f = 10**dp;
  return Math.round((+x + Number.EPSILON)*f)/f;
}
function fmt(x, maxDp=6){
  const n = Number(x);
  if(!Number.isFinite(n)) return String(x);
  const s = n.toFixed(maxDp);
  return s.replace(/\.?0+$/,"");
}
function simpFrac(n,d){
  if(d===0) return {n:NaN,d:NaN};
  if(d<0){n=-n;d=-d}
  const g=gcd(n,d);
  return {n:n/g,d:d/g};
}
function fracEq(a,b){
  const x=simpFrac(a.n,a.d), y=simpFrac(b.n,b.d);
  return x.n===y.n && x.d===y.d;
}
function asNum(v){
  const s = String(v??"").trim().replace(/,/g,"");
  if(!s) return NaN;
  // allow fraction "a/b" in numeric fields
  if(s.includes("/")){
    const m = s.match(/^(-?\d+)\s*\/\s*(-?\d+)$/);
    if(!m) return NaN;
    const n=Number(m[1]), d=Number(m[2]);
    if(!Number.isFinite(n)||!Number.isFinite(d)||d===0) return NaN;
    return n/d;
  }
  // allow leading +, decimals
  const x = Number(s);
  return Number.isFinite(x) ? x : NaN;
}
function close(a,b,tol=1e-8){ return Math.abs(a-b) <= tol; }

function parseStandardFormInput(raw){
  // Accept forms like:
  // 3.2×10⁵   3.2x10^5   3.2E5   3.2×10-5  (Unicode superscripts supported)
  const s0 = String(raw ?? "").trim();
  if(!s0) return null;

  // Normalise
  let s = s0.replace(/\s+/g,"");
  s = s.replace(/×/g,"x").replace(/⋅/g,"x").replace(/·/g,"x");
  s = s.replace(/EXP/ig,"E");
  s = s.replace(/[−–—]/g,"-"); // unicode minus/dashes

  // Convert Unicode superscripts to normal digits/sign
  const supMap = {"⁰":"0","¹":"1","²":"2","³":"3","⁴":"4","⁵":"5","⁶":"6","⁷":"7","⁸":"8","⁹":"9","⁻":"-","⁺":"+"};
  s = s.replace(/[⁰¹²³⁴⁵⁶⁷⁸⁹⁻⁺]/g, ch => supMap[ch] ?? ch);

  // Standardise multiply symbol
  s = s.replace(/X/g,"x");

  // Pattern A: mantissa E exponent
  let m = s.match(/^([+-]?\d*\.?\d+)E([+-]?\d+)$/i);
  if(m){
    const mantissa = Number(m[1]);
    const exp = parseInt(m[2],10);
    if(!Number.isFinite(mantissa) || !Number.isFinite(exp)) return null;
    return {mantissa, exp, value: mantissa * Math.pow(10, exp)};
  }

  // Pattern B: mantissa × 10 ^ exponent  (caret optional, exponent may follow immediately after 10)
  m = s.match(/^([+-]?\d*\.?\d+)(?:x|\*)10\^?([+-]?\d+)$/i);
  if(m){
    const mantissa = Number(m[1]);
    const exp = parseInt(m[2],10);
    if(!Number.isFinite(mantissa) || !Number.isFinite(exp)) return null;
    return {mantissa, exp, value: mantissa * Math.pow(10, exp)};
  }

  return null;
}


/* -------------------- MathML helpers -------------------- */
const MNS = `http://www.w3.org/1998/Math/MathML`;
function mfrac(n,d){
  return `<span class="mathwrap"><math xmlns="${MNS}" display="inline"><mfrac><mn>${n}</mn><mn>${d}</mn></mfrac></math></span>`;
}
function msup(base, exp){
  const baseNode = Number.isFinite(+base) ? `<mn>${base}</mn>` : `<mi>${String(base)}</mi>`;
  return `<span class="mathwrap"><math xmlns="${MNS}" display="inline"><msup>${baseNode}<mn>${exp}</mn></msup></math></span>`;
}

function mEsc(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");
}
function mml(inner){
  return `<span class="mathwrap"><math xmlns="${MNS}" display="inline">${inner}</math></span>`;
}
function mmn(v){ return `<mn>${mEsc(v)}</mn>`; }
function mmi(v){ return `<mi>${mEsc(v)}</mi>`; }
function mmo(v){
  const esc = mEsc(v);
  if(v==="×" || v==="÷"){
    return `<mspace width="0.2em"/><mo>${esc}</mo><mspace width="0.2em"/>`;
  }
  return `<mo>${esc}</mo>`;
}
function mmt(v){ return `<mtext>${mEsc(v)}</mtext>`; }
function mrowN(...nodes){ return `<mrow>${nodes.join("")}</mrow>`; }
function mfencedN(inner){ return `<mrow><mo>(</mo>${inner}<mo>)</mo></mrow>`; }
function msqrtN(inner){ return `<msqrt>${inner}</msqrt>`; }
function mrootN(radicandInner, indexInner){ return `<mroot>${radicandInner}${indexInner}</mroot>`; }
function msupN(baseNode, exp){
  const eNode = Number.isFinite(+exp) ? mmn(exp) : mmi(exp);
  return `<msup>${baseNode}${eNode}</msup>`;
}


// SECTION: Topic list / tab navigation
// EDIT HERE: To add/remove topics or change the tab label, edit the TOPICS array below.
// NOTE: Each `code` must have a corresponding `case "CODE"` in the buildQuestion() switch.
/* SPLITMERGE:TOPICS-START */
const TOPICS = [
  {code:"N10", name:"Order of operations (BIDMAS)"},
  {code:"N11", name:"Inverse operations & missing numbers"},
  {code:"N12", name:"Factors & multiples"}
];
/* SPLITMERGE:TOPICS-END */

/* -------------------- number pickers -------------------- */
function pickDec(rng, dp){
  // dp digits after decimal, always non-trailing safe
  const m = 10**dp;
  return rng.int(1*m, 999*m)/m;
}
function pickMoney(rng, isCalc){
  // money prices: noncalc => 2 dp but friendly; calc => awkward 2 dp
  const pennies = isCalc ? rng.int(105, 2999) : rng.choice([125,150,175,200,225,250,275,300,350,400,450,500,550,600,650,700,750,800,900,1000,1200,1500]);
  return pennies/100;
}
function pickNiceInt(rng, min=2, max=40){ return rng.int(min, max); }
function pickBigInt(rng){ return rng.int(1200, 98000); }

function pickPercent(rng, allowOneDp=false){
  // GCSE-friendly percentages (no recurring). If allowOneDp, may return values like 12.5 or 7.5.
  const ints = [1,2,3,4,5,6,8,10,12,15,18,20,25,30,35,40,45,50,60,75,80,90];
  const oneDp = [2.5,7.5,12.5,17.5,22.5,37.5,62.5];
  return allowOneDp ? rng.choice(ints.concat(oneDp)) : rng.choice(ints);
}

/* -------------------- part constructors -------------------- */
function partNumber(id, textHtml, marks, value){
  return {marks, textHtml, input:{kind:"number", id}, answer:{type:"number", value}};
}
function partInteger(id, textHtml, marks, value){
  return {marks, textHtml, input:{kind:"integer", id}, answer:{type:"number", value}};
}
function partFraction(id, textHtml, marks, frac){
  return {marks, textHtml, input:{kind:"fraction", id}, answer:{type:"fraction", value: frac}};
}
function partPair(id, textHtml, marks, pair, opts={}){
  return {marks, textHtml, input:{kind:(opts.kind||"pair"), id, placeholders:opts.placeholders, labels:opts.labels}, answer:{type:"pair", value: pair}};
}
function partStdForm(id, textHtml, marks, val, nMaybe){
  // val can be:
  //  - the actual numeric value to be written in standard form, OR
  //  - (A, n) where val is A and nMaybe is the power of 10.
  const num = (typeof nMaybe !== "undefined")
    ? (Number(val) * (10**Number(nMaybe)))
    : Number(val);
  return {marks, textHtml, input:{kind:"standardForm", id}, answer:{type:"standardForm", value: num}};
}
function partOrder(id, textHtml, marks, correctTokens){
  return {marks, textHtml, input:{kind:"order", id}, answer:{type:"order", value: correctTokens}};
}
function partPrimeFactors(id, textHtml, marks, primeMap){
  // primeMap: {2:3, 3:1, ...}
  return {marks, textHtml, input:{kind:"primeFactors", id}, answer:{type:"primeFactors", value: primeMap}};
}
function partMoney(id, textHtml, marks, value){
  return {marks, textHtml, input:{kind:"money", id}, answer:{type:"number", value}};
}

function partSymbol(id, textHtml, marks, value){
  return {marks, textHtml, input:{kind:"symbol", id}, answer:{type:"symbol", value}};
}

/* -------------------- prime factor helpers -------------------- */
function factorise(n){
  // returns map {p:exp}, n is integer >=2
  let x = Math.abs(Math.trunc(n));
  const map = {};
  let p = 2;
  while(p*p <= x){
    while(x % p === 0){
      map[p] = (map[p]||0) + 1;
      x = Math.trunc(x/p);
    }
    p = (p===2) ? 3 : p+2;
  }
  if(x>1) map[x] = (map[x]||0)+1;
  return map;
}
function mapsEqual(a,b){
  const ka = Object.keys(a).sort();
  const kb = Object.keys(b).sort();
  if(ka.length!==kb.length) return false;
  for(let i=0;i<ka.length;i++){
    if(ka[i]!==kb[i]) return false;
    if(a[ka[i]]!==b[kb[i]]) return false;
  }
  return true;
}

// SECTION: Build one question card (topic + mark band)
// EDIT HERE: Each topic's question generator lives inside the switch(topicCode) below.
// - Adjust wording/values/answer keys within a topic `case`.
// - Keep IDs/classnames stable (the UI + checking logic rely on them).
// - To add a new topic, add it to TOPICS and add a matching case in this switch.
function buildQuestion(topicCode, marksTotal, paperMode, rng){
  const isCalc = paperMode === "calc";

  // SECTION: Scenario/context variants (3+ marks only)
  // These are injected directly into the student-facing prompt text (no separate context label above the question).
  // CHANGE REQUESTS #5/#6: N5 and N11 contexts are now specific and randomly selected.
  const contextVariants = (code)=>{
    switch(code){
      case "N7":
      case "N47":
        return [
        "A customer is buying items in a local shop.",
        "A group is buying tickets and snacks at a cinema.",
        "A charity stall is selling items to raise money."
        ];
      case "N46":
        return [
        "A cyclist records a distance and the time taken for a journey.",
        "A driver records a distance and the time taken for a trip.",
        "A runner records a distance and the time taken for training."
        ];
      case "N48":
        return [
        "A student uses a timetable to work out times during the day.",
        "A traveller plans a journey using start times and durations.",
        "An athlete uses race times and durations to plan a schedule."
        ];
      case "N37":
      case "N38":
      case "N39":
      case "N49":
      case "N50":
        return [
        "A scientist writes very large numbers using standard form.",
        "A lab report uses standard form for very small measurements.",
        "A computer stores very large and very small values in standard form."
        ];
      case "N43":
      case "N44":
      case "N45":
        return [
        "A technician records a measurement rounded to a stated accuracy.",
        "A coach records a distance or time rounded to a stated accuracy.",
        "A science experiment records readings rounded to a stated accuracy."
        ];
      // CHANGE REQUEST #6 (N11): Replace vague scenario prompts with specific, realistic contexts.
      case "N11":
        return [
        "A café uses a till that does two steps to work out a bill total.",
        "A delivery company uses a two-step rule to work out charges for parcels.",
        "A school club uses a two-step rule to work out how many packs are needed."
        ];
      case "N12":
      case "N13":
      case "N14":
      case "N15":
      case "N16":
      case "N32":
        return [
        "Items are being packed into equal groups.",
        "A team is arranging equipment evenly.",
        "A factory is making products in equal batches."
        ];
      case "N17":
      case "N18":
      case "N19":
      case "N20":
      case "N21":
      case "N22":
      case "N23":
      case "N24":
      case "N25":
      case "N26":
      case "N31":
        return [
        "A recipe uses fractional amounts of ingredients and portions.",
        "A DIY job uses fractions to measure, cut and share materials.",
        "A sports setting uses fractions of a lap or a match."
        ];
      // CHANGE REQUEST #5 (N5): Provide specific contexts for addition/subtraction (including negatives).
      case "N5":
        return [
        "A bank account changes with deposits and withdrawals.",
        "A temperature changes overnight, then changes again during the day.",
        "A football team tracks points gained and points lost across two matches."
        ];
      case "N27":
      case "N28":
      case "N29":
      case "N30":
      case "N33":
      case "N34":
      case "N35":
      case "N36":
        return [
        "A shop is using prices, discounts and offers.",
        "A charity is tracking amounts towards a target.",
        "A school is comparing scores and attendance figures."
        ];
      default:
        return [
        "A student is using numbers from an everyday situation.",
        "Someone is using numbers to complete a practical task.",
        "A real-life problem requires interpreting numbers accurately."
        ];
    }
  };

  // helper: create object
  const Q = (parts)=>{
    // For 3–5 mark questions, randomly select ONE of three context variants
    // and prepend it to the prompt. (Maths stays identical; only the setting changes.)
    if(marksTotal>=3 && topicCode!=="N10"){
      const leads = contextVariants(topicCode) || [];
      if(leads.length>=3){
        const lead = rng.choice(leads);
        for(const p of parts){
          if(p && typeof p.textHtml==="string" && p.textHtml.trim()!==""){
            // Insert the chosen scenario into the question text itself (no separate context line).
            const original = p.textHtml;
            const trimmed = original.trimStart();
            if(trimmed.toLowerCase().startsWith('<p')){
              const idx = original.toLowerCase().indexOf('<p');
              const end = original.indexOf('>', idx);
              if(end !== -1){
                p.textHtml = original.slice(0, end+1) + lead + ' ' + original.slice(end+1);
              } else {
                p.textHtml = lead + ' ' + original;
              }
            } else {
              p.textHtml = lead + ' ' + original;
            }
            break;
          }
        }
      }
    }
    return {topicCode, marksTotal, paperMode, parts};
  };

  // helper: "calc style" rounding to 2 dp for awkward results
  const need2dp = isCalc; // calculator questions will often say 2 d.p.

  switch(topicCode){
    /* SPLITMERGE:BUILDQUESTION-CASES-START */
    /* ===================== N10 BIDMAS ===================== */
    
    /* ===================== N10 BIDMAS (order of operations) ===================== */
    case "N10": {
      // N10: Order of operations (BIDMAS)
      // Rules:
      // - Non-calculator: whole numbers only (and answers are whole numbers)
      // - Calculator: decimals included; student rounds to 2 d.p.
      // - 4–5 mark questions use tables and parts (a) and (b)
      // Brackets: aim for an equal mix of questions with brackets vs without brackets.
      const DP = 2;

      const roundAns = (x)=> isCalc ? roundTo(x, DP) : x;

      const dec = (min, max, dp)=>{
        const sc = 10**dp;
        const lo = Math.ceil(min*sc);
        const hi = Math.floor(max*sc);
        let n = lo;
        for(let t=0;t<250;t++){
          n = rng.int(lo, hi);
          // avoid whole numbers if we can (still OK if it happens)
          if(n % sc !== 0) break;
        }
        const v = n / sc;
        return {v, s: v.toFixed(dp)};
      };

      const squareFromRoot = (minRoot, maxRoot, dpRoot=1)=>{
        // choose root with dpRoot dp, and return an EXACT square (to 2*dpRoot dp)
        const sc = 10**dpRoot;
        const rInt = rng.int(Math.ceil(minRoot*sc), Math.floor(maxRoot*sc));
        const root = rInt / sc;
        const rad = (rInt*rInt) / (sc*sc);
        return {root, rootStr: root.toFixed(dpRoot), rad, radStr: rad.toFixed(dpRoot*2)};
      };

      const cubeFromRoot = (minRoot, maxRoot, dpRoot=1)=>{
        // choose root with dpRoot dp, and return an EXACT cube (to 3*dpRoot dp)
        const sc = 10**dpRoot;
        const rInt = rng.int(Math.ceil(minRoot*sc), Math.floor(maxRoot*sc));
        const root = rInt / sc;
        const rad = (rInt*rInt*rInt) / (sc*sc*sc);
        return {root, rootStr: root.toFixed(dpRoot), rad, radStr: rad.toFixed(dpRoot*3)};
      };

      const coin = ()=> rng.float() < 0.5;

      const workOutLine = (prefix, exprHtml, marks)=>{
        const p = (prefix ?? "").trim();
        const pfx = p ? `<b>${p}</b> ` : "";
        const mark = `<span class="endmark">[${marks}]</span>`;

        const line1 = isCalc
          ? `<div class="wo-text">${pfx}Work out:</div>`
          : `<div class="wo-text">${pfx}Work out: ${mark}</div>`;

        const line3 = isCalc
          ? `<div class="wo-text">Give your answer to 2 decimal places. ${mark}</div>`
          : ``;

        return `
          <div class="wo-block">
            ${line1}
            <div class="wo-row">
              <div class="wo-math">${exprHtml}</div>
              <div class="wo-ans">{{INPUT}}</div>
            </div>
            ${line3}
          </div>
        `;
      };

      const makePart = (id, textHtml, marks, value)=>{
        if(isCalc){
          const p = partNumber(id, textHtml, marks, roundTo(value, DP));
          p.answer.dp = DP;
          return p;
        }
        return partInteger(id, textHtml, marks, value);
      };

      const tableHtml = (rows)=>{
        const body = rows.map(r=>`<tr><td>${r.name}</td><td>${r.val}</td></tr>`).join("");
        return `
          <table class="valtable" aria-label="values table">
            <thead><tr><th>Value name</th><th>Value</th></tr></thead>
            <tbody>${body}</tbody>
          </table>
        `;
      };

      /* -------------------- 1 MARK (2 operations) -------------------- */
      if(marksTotal===1){
        const scenario = rng.int(1,4);

        // Scenario 1 (money): A − b×c  (NO brackets)
        if(scenario===1){
          if(!isCalc){
            const b = rng.int(2,12);
            const c = rng.int(2,9);
            const A = b*c + rng.int(5,60);

            const expr = mml(mrowN(mmn(A), mmo("−"), mmn(b), mmo("×"), mmn(c)));
            const ans = A - b*c;
            return Q([makePart("n10_1", workOutLine("", expr, 1), 1, ans)]);
          } else {
            const b = dec(2,12,2);
            const c = dec(2,9,1);
            const extra = dec(5,60,1);
            const A = roundTo(b.v*c.v + extra.v, 1);
            const AStr = A.toFixed(1);

            const expr = mml(mrowN(mmn(AStr), mmo("−"), mmn(b.s), mmo("×"), mmn(c.s)));
            const ans = A - b.v*c.v;
            return Q([makePart("n10_1", workOutLine("", expr, 1), 1, ans)]);
          }
        }

        // Scenario 2: −A + b×c  (NO brackets)
        if(scenario===2){
          if(!isCalc){
            const A = rng.int(3,15);
            const b = rng.int(2,9);
            const c = rng.int(2,9);

            const expr = mml(mrowN(mmo("−"), mmn(A), mmo("+"), mmn(b), mmo("×"), mmn(c)));
            const ans = -A + b*c;
            return Q([makePart("n10_2", workOutLine("", expr, 1), 1, ans)]);
          } else {
            const A = dec(3,18,1);
            const b = dec(2,9,2);
            const c = dec(2,9,1);

            const expr = mml(mrowN(mmo("−"), mmn(A.s), mmo("+"), mmn(b.s), mmo("×"), mmn(c.s)));
            const ans = -A.v + b.v*c.v;
            return Q([makePart("n10_2", workOutLine("", expr, 1), 1, ans)]);
          }
        }

        // Scenario 3: d×(e−f)  (WITH brackets)
        if(scenario===3){
          if(!isCalc){
            const d = rng.int(2,12);
            const f = rng.int(3,18);
            const e = f + rng.int(2,20);

            const exprA = mml(mrowN(mmn(d), mmo("×"), mfencedN(mrowN(mmn(e), mmo("−"), mmn(f)))));
            const exprB = mml(mrowN(mfencedN(mrowN(mmn(e), mmo("−"), mmn(f))), mmo("×"), mmn(d)));
            const expr = rng.choice([exprA, exprB]);

            const ans = d*(e-f);
            return Q([makePart("n10_3", workOutLine("", expr, 1), 1, ans)]);
          } else {
            const d = dec(2,12,1);
            const e = dec(10,30,1);
            const f = dec(2, e.v-1, 2);

            const exprA = mml(mrowN(mmn(d.s), mmo("×"), mfencedN(mrowN(mmn(e.s), mmo("−"), mmn(f.s)))));
            const exprB = mml(mrowN(mfencedN(mrowN(mmn(e.s), mmo("−"), mmn(f.s))), mmo("×"), mmn(d.s)));
            const expr = rng.choice([exprA, exprB]);

            const ans = d.v*(e.v - f.v);
            return Q([makePart("n10_3", workOutLine("", expr, 1), 1, ans)]);
          }
        }

        // Scenario 4 (extra brackets): (x + 5) / 2  (WITH brackets)
        if(scenario===4){
          if(!isCalc){
            let x = rng.int(1,45);
            // make (x+5)/2 an integer
            if(x % 2 === 0) x += 1;
            if(x > 45) x -= 2;

            const expr = mml(`<mfrac>${mfencedN(mrowN(mmn(x), mmo("+"), mmn(5)))}${mmn(2)}</mfrac>`);
            const ans = (x + 5) / 2;
            return Q([makePart("n10_16", workOutLine("", expr, 1), 1, ans)]);
          } else {
            const x = dec(10, 90, 2);
            const expr = mml(`<mfrac>${mfencedN(mrowN(mmn(x.s), mmo("+"), mmn("5.0")))}${mmn("2.0")}</mfrac>`);
            const ans = (x.v + 5.0) / 2.0;
            return Q([makePart("n10_16", workOutLine("", expr, 1), 1, ans)]);
          }
        }
      }

      /* -------------------- 2 MARK (3 operations) -------------------- */
      if(marksTotal===2){
        const scenario = rng.int(1,3);

        // Scenario 1 (money): (p−q)×r + s  (WITH brackets)
        if(scenario===1){
          if(!isCalc){
            const p = rng.int(12,30);
            const q = rng.int(2, Math.min(18,p-1));
            const r = rng.int(2,8);
            const s = rng.int(2,15);

            const pq = mfencedN(mrowN(mmn(p), mmo("−"), mmn(q)));
            const exprA = mml(mrowN(pq, mmo("×"), mmn(r), mmo("+"), mmn(s)));
            const exprB = mml(mrowN(mmn(s), mmo("+"), pq, mmo("×"), mmn(r)));
            const expr = rng.choice([exprA, exprB]);

            const ans = (p - q)*r + s;
            return Q([makePart("n10_4", workOutLine("", expr, 2), 2, ans)]);
          } else {
            const p = dec(12,50,1);
            const q = dec(2, Math.max(3, Math.min(18, p.v-0.5)), 2);
            const r = dec(2,8,1);
            const s = dec(2,20,2);

            const pq = mfencedN(mrowN(mmn(p.s), mmo("−"), mmn(q.s)));
            const exprA = mml(mrowN(pq, mmo("×"), mmn(r.s), mmo("+"), mmn(s.s)));
            const exprB = mml(mrowN(mmn(s.s), mmo("+"), pq, mmo("×"), mmn(r.s)));
            const expr = rng.choice([exprA, exprB]);

            const ans = (p.v - q.v)*r.v + s.v;
            return Q([makePart("n10_4", workOutLine("", expr, 2), 2, ans)]);
          }
        }

        // Scenario 2: x² − a×b  (MIX: brackets around product 50% of the time)
        if(scenario===2){
          const withBrackets = coin();
          if(!isCalc){
            const x = rng.int(2,15);
            const a = rng.int(2,12);
            const b = rng.int(2,12);

            const xSq = msupN(mmn(x), 2);
            const prod = mrowN(mmn(a), mmo("×"), mmn(b));
            const right = withBrackets ? mfencedN(prod) : prod;

            const expr = mml(mrowN(xSq, mmo("−"), right));
            const ans = x*x - a*b;
            return Q([makePart("n10_5", workOutLine("", expr, 2), 2, ans)]);
          } else {
            const x = dec(2,15,1);
            const a = dec(2,15,2);
            const b = dec(2,15,1);

            const xSq = msupN(mmn(x.s), 2);
            const prod = mrowN(mmn(a.s), mmo("×"), mmn(b.s));
            const right = withBrackets ? mfencedN(prod) : prod;

            const expr = mml(mrowN(xSq, mmo("−"), right));
            const ans = (x.v*x.v) - (a.v*b.v);
            return Q([makePart("n10_5", workOutLine("", expr, 2), 2, ans)]);
          }
        }

        // Scenario 3: p÷q + r×s  (NO brackets)
        if(scenario===3){
          if(!isCalc){
            const q = rng.int(2,12);
            const quot = rng.int(3,20);
            const p = q * quot;
            const r = rng.int(2,12);
            const s = rng.int(2,12);

            const left = mrowN(mmn(p), mmo("÷"), mmn(q));
            const right = mrowN(mmn(r), mmo("×"), mmn(s));

            const exprA = mml(mrowN(left, mmo("+"), right));
            const exprB = mml(mrowN(right, mmo("+"), left));
            const expr = rng.choice([exprA, exprB]);

            const ans = (p / q) + r*s;
            return Q([makePart("n10_6", workOutLine("", expr, 2), 2, ans)]);
          } else {
            const q = dec(3,12,1);
            const quot = dec(5,25,1);
            const pVal = q.v * quot.v;
            const pStr = pVal.toFixed(2);
            const r = dec(2,12,2);
            const s = dec(2,12,1);

            const left = mrowN(mmn(pStr), mmo("÷"), mmn(q.s));
            const right = mrowN(mmn(r.s), mmo("×"), mmn(s.s));

            const exprA = mml(mrowN(left, mmo("+"), right));
            const exprB = mml(mrowN(right, mmo("+"), left));
            const expr = rng.choice([exprA, exprB]);

            const ans = (pVal / q.v) + (r.v * s.v);
            return Q([makePart("n10_6", workOutLine("", expr, 2), 2, ans)]);
          }
        }
      }

      /* -------------------- 3 MARK (4 operations) -------------------- */
      if(marksTotal===3){
        const scenario = rng.int(1,3);

        // Scenario 1 (money): A − b×c + d÷e  (MIX brackets 50% of the time)
        if(scenario===1){
          const withBrackets = coin();
          if(!isCalc){
            const b = rng.int(2,12);
            const c = rng.int(2,8);
            const e = rng.int(2,10);
            const q = rng.int(2,12);
            const d = e*q;
            const A = b*c + rng.int(10,80);

            const bc = mrowN(mmn(b), mmo("×"), mmn(c));
            const bcNode = withBrackets ? mfencedN(bc) : bc;

            const de = mrowN(mmn(d), mmo("÷"), mmn(e));

            const exprA = mml(mrowN(mmn(A), mmo("−"), bcNode, mmo("+"), de));
            const exprB = mml(mrowN(mmn(A), mmo("+"), de, mmo("−"), bcNode));
            const expr = rng.choice([exprA, exprB]);

            const ans = A - (b*c) + (d/e);
            return Q([makePart("n10_7", workOutLine("", expr, 3), 3, ans)]);
          } else {
            const A = dec(40,120,1);
            const b = dec(2,12,2);
            const c = dec(2,8,2);
            const d = dec(10,40,1);
            const e = dec(2,12,2);

            const bc = mrowN(mmn(b.s), mmo("×"), mmn(c.s));
            const bcNode = withBrackets ? mfencedN(bc) : bc;

            const de = mrowN(mmn(d.s), mmo("÷"), mmn(e.s));

            const exprA = mml(mrowN(mmn(A.s), mmo("−"), bcNode, mmo("+"), de));
            const exprB = mml(mrowN(mmn(A.s), mmo("+"), de, mmo("−"), bcNode));
            const expr = rng.choice([exprA, exprB]);

            const ans = A.v - (b.v*c.v) + (d.v/e.v);
            return Q([makePart("n10_7", workOutLine("", expr, 3), 3, ans)]);
          }
        }

        // Scenario 2: √rad + base²×mult − sub  (MIX brackets 50% of the time)
        if(scenario===2){
          const withBrackets = coin();
          if(!isCalc){
            const squares = [16,25,36,49,64,81,100,121,144,169,196,225];
            const rad = rng.choice(squares);
            const base = rng.int(2,15);
            const mult = rng.int(2,6);
            const sub = rng.int(2,20);

            const root = msqrtN(mmn(rad));
            const baseSq = msupN(mmn(base), 2);

            const prod = mrowN(baseSq, mmo("×"), mmn(mult));
            const prodNode = withBrackets ? mfencedN(prod) : prod;

            const exprA = mml(mrowN(root, mmo("+"), prodNode, mmo("−"), mmn(sub)));
            const exprB = mml(mrowN(prodNode, mmo("+"), root, mmo("−"), mmn(sub)));
            const expr = rng.choice([exprA, exprB]);

            const ans = Math.sqrt(rad) + (base*base)*mult - sub;
            return Q([makePart("n10_8", workOutLine("", expr, 3), 3, ans)]);
          } else {
            const sq = squareFromRoot(6, 14, 1); // e.g. 9.2^2 = 84.64
            const base = dec(2,15,1);
            const mult = dec(2,6,1);
            const sub = dec(2,20,1);

            const root = msqrtN(mmn(sq.radStr));
            const baseSq = msupN(mmn(base.s), 2);

            const prod = mrowN(baseSq, mmo("×"), mmn(mult.s));
            const prodNode = withBrackets ? mfencedN(prod) : prod;

            const exprA = mml(mrowN(root, mmo("+"), prodNode, mmo("−"), mmn(sub.s)));
            const exprB = mml(mrowN(prodNode, mmo("+"), root, mmo("−"), mmn(sub.s)));
            const expr = rng.choice([exprA, exprB]);

            const ans = sq.root + (base.v*base.v)*mult.v - sub.v;
            return Q([makePart("n10_8", workOutLine("", expr, 3), 3, ans)]);
          }
        }

        // Scenario 3 (includes cube root): (∛cube + add) ÷ div − sub
        // MIX: 50% show with brackets + ÷, 50% show as a fraction (no brackets)
        if(scenario===3){
          const withBrackets = coin();
          if(!isCalc){
            const r = rng.int(2,8);
            const cube = r*r*r;
            const div = rng.int(2,6);

            // Choose add so (r+add) is divisible by div and keep whole numbers
            const kMin = Math.ceil((r+1)/div);
            const k = rng.int(Math.max(kMin,4), 14);
            const add = div*k - r;
            const sub = rng.int(1, Math.max(1, k-1));

            const cbrt = mrootN(mmn(cube), mmn(3));
            const sum = mrowN(cbrt, mmo("+"), mmn(add));

            const fracOrDiv = withBrackets
              ? mrowN(mfencedN(sum), mmo("÷"), mmn(div))
              : `<mfrac>${sum}${mmn(div)}</mfrac>`;

            const expr = mml(mrowN(fracOrDiv, mmo("−"), mmn(sub)));
            const ans = ((r + add) / div) - sub;
            return Q([makePart("n10_9", workOutLine("", expr, 3), 3, ans)]);
          } else {
            const cb = cubeFromRoot(2.5, 6.5, 1); // e.g. 4.5^3 = 91.125
            const add = dec(10,25,1);
            const div = dec(2.5,6.5,2);
            const sub = dec(2,10,2);

            const cbrt = mrootN(mmn(cb.radStr), mmn(3));
            const sum = mrowN(cbrt, mmo("+"), mmn(add.s));

            const fracOrDiv = withBrackets
              ? mrowN(mfencedN(sum), mmo("÷"), mmn(div.s))
              : `<mfrac>${sum}${mmn(div.s)}</mfrac>`;

            const expr = mml(mrowN(fracOrDiv, mmo("−"), mmn(sub.s)));
            const ans = ((cb.root + add.v) / div.v) - sub.v;
            return Q([makePart("n10_9", workOutLine("", expr, 3), 3, ans)]);
          }
        }
      }

      /* -------------------- 4 MARK (table + parts a/b) -------------------- */
      if(marksTotal===4){
        const scenario = rng.int(1,3);
        const withBrackets = coin(); // question-level bracket toggle (aim for equal mix)

        // Scenario 1 (money table): cinema charges
        if(scenario===1){
          if(!isCalc){
            const ticket = rng.int(6,15);
            const fee = rng.int(1,6);
            const service = rng.int(2,6);

            // Ensure (ticket*8 - voucher) is divisible by service for an integer answer
            const maxK = Math.max(1, Math.floor((ticket*8 - 1) / service));
            const k = rng.int(1, maxK);
            const voucher = (ticket*8) - (k*service);

            const rows = [
              {name:"Ticket price", val:mml(mmn(ticket))},
              {name:"Booking fee", val:mml(mmn(fee))},
              {name:"Voucher discount", val:mml(mmn(voucher))},
              {name:"Service charge", val:mml(mmn(service))}
            ];

            const intro =
              `A cinema charges for tickets.<br>`+
              `There are also extra charges and discounts.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            // (a) 2 ops: ticket price × 5 + booking fee
            const aCore = mrowN(mmt("ticket price"), mmo("×"), mmn(5));
            const aExpr = withBrackets
              ? mml(mrowN(mfencedN(aCore), mmo("+"), mmt("booking fee")))
              : mml(mrowN(aCore, mmo("+"), mmt("booking fee")));

            // (b) 4 ops max: (ticket price × 8 − voucher discount) ÷ service charge
            const numCore = mrowN(mmt("ticket price"), mmo("×"), mmn(8), mmo("−"), mmt("voucher discount"));
            const bExpr = withBrackets
              ? mml(mrowN(mfencedN(numCore), mmo("÷"), mmt("service charge")))
              : mml(`<mfrac>${numCore}${mmt("service charge")}</mfrac>`);

            const aAns = ticket*5 + fee;
            const bAns = ((ticket*8) - voucher) / service;

            return Q([
              makePart("n10_10a", intro + workOutLine("(a) ", aExpr, 1), 1, aAns),
              makePart("n10_10b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          } else {
            const ticket = dec(6,15,2);
            const fee = dec(1,6,2);
            const service = dec(2,6,2);

            // keep voucher smaller than ticket*8 so the numerator stays positive
            const maxVoucher = Math.max(0.5, ticket.v*8 - 0.5);
            const voucher = dec(0.5, Math.min(15, maxVoucher), 2);

            const rows = [
              {name:"Ticket price", val:mml(mmn(ticket.s))},
              {name:"Booking fee", val:mml(mmn(fee.s))},
              {name:"Voucher discount", val:mml(mmn(voucher.s))},
              {name:"Service charge", val:mml(mmn(service.s))}
            ];

            const intro =
              `A cinema charges for tickets.<br>`+
              `There are also extra charges and discounts.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            const aCore = mrowN(mmt("ticket price"), mmo("×"), mmn(5));
            const aExpr = withBrackets
              ? mml(mrowN(mfencedN(aCore), mmo("+"), mmt("booking fee")))
              : mml(mrowN(aCore, mmo("+"), mmt("booking fee")));

            const numCore = mrowN(mmt("ticket price"), mmo("×"), mmn(8), mmo("−"), mmt("voucher discount"));
            const bExpr = withBrackets
              ? mml(mrowN(mfencedN(numCore), mmo("÷"), mmt("service charge")))
              : mml(`<mfrac>${numCore}${mmt("service charge")}</mfrac>`);

            const aAns = ticket.v*5 + fee.v;
            const bAns = ((ticket.v*8) - voucher.v) / service.v;

            return Q([
              makePart("n10_10a", intro + workOutLine("(a) ", aExpr, 1), 1, aAns),
              makePart("n10_10b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          }
        }

        // Scenario 2 (table): coach company times
        // NOTE: Avoids sums inside square roots and avoids part (b) reusing part (a).
        if(scenario===2){
          if(!isCalc){
            // Choose Section B and stop time so Section B × stop time is a perfect square.
            const root = rng.int(4,15);
            const square = root*root;

            // Pick a divisor for Section B
            const divisors = [];
            for(let d=2; d<=square; d++){
              if(square % d === 0) divisors.push(d);
            }
            const secB = rng.choice(divisors);
            const stop = square / secB;

            const secA = rng.int(10,30);
            const delay = rng.int(2,12);

            const rows = [
              {name:"Section A", val:mml(mmn(secA))},
              {name:"Section B", val:mml(mmn(secB))},
              {name:"Stop time", val:mml(mmn(stop))},
              {name:"Delay", val:mml(mmn(delay))}
            ];

            const intro =
              `A coach company records times for parts of a route.<br>`+
              `A delay can be added.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            // (a) [1] 2 ops
            // Bracketless: Section B × delay − stop time
            // Bracketed:   Section B × (delay − stop time)
            const aExpr = withBrackets
              ? mml(mrowN(mmt("Section B"), mmo("×"), mfencedN(mrowN(mmt("delay"), mmo("−"), mmt("stop time")))))
              : mml(mrowN(mmt("Section B"), mmo("×"), mmt("delay"), mmo("−"), mmt("stop time")));

            // (b) [3] 4 ops max (and does NOT reuse (a))
            // Section A + √(Section B × stop time) − delay
            const rootInner = mrowN(mmt("Section B"), mmo("×"), mmt("stop time"));
            const sqrtTerm = msqrtN(rootInner);
            const bCore = mrowN(mmt("Section A"), mmo("+"), sqrtTerm, mmo("−"), mmt("delay"));
            const bExpr = withBrackets
              ? mml(mrowN(mfencedN(mrowN(mmt("Section A"), mmo("+"), sqrtTerm)), mmo("−"), mmt("delay")))
              : mml(bCore);

            const aAns = withBrackets
              ? (secB * (delay - stop))
              : (secB * delay - stop);

            const bAns = secA + Math.sqrt(secB*stop) - delay;

            return Q([
              makePart("n10_11a", intro + workOutLine("(a) ", aExpr, 1), 1, aAns),
              makePart("n10_11b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          } else {
            const secA = dec(12,30,2);
            const secB = dec(6,20,2);
            const stop = dec(2,12,2);
            const delay = dec(2,12,2);

            const rows = [
              {name:"Section A", val:mml(mmn(secA.s))},
              {name:"Section B", val:mml(mmn(secB.s))},
              {name:"Stop time", val:mml(mmn(stop.s))},
              {name:"Delay", val:mml(mmn(delay.s))}
            ];

            const intro =
              `A coach company records times for parts of a route.<br>`+
              `A delay can be added.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            const aExpr = withBrackets
              ? mml(mrowN(mmt("Section B"), mmo("×"), mfencedN(mrowN(mmt("delay"), mmo("−"), mmt("stop time")))))
              : mml(mrowN(mmt("Section B"), mmo("×"), mmt("delay"), mmo("−"), mmt("stop time")));

            const rootInner = mrowN(mmt("Section B"), mmo("×"), mmt("stop time"));
            const sqrtTerm = msqrtN(rootInner);
            const bCore = mrowN(mmt("Section A"), mmo("+"), sqrtTerm, mmo("−"), mmt("delay"));
            const bExpr = withBrackets
              ? mml(mrowN(mfencedN(mrowN(mmt("Section A"), mmo("+"), sqrtTerm)), mmo("−"), mmt("delay")))
              : mml(bCore);

            const aAns = withBrackets
              ? (secB.v * (delay.v - stop.v))
              : (secB.v * delay.v - stop.v);

            const bAns = secA.v + Math.sqrt(secB.v*stop.v) - delay.v;

            return Q([
              makePart("n10_11a", intro + workOutLine("(a) ", aExpr, 1), 1, aAns),
              makePart("n10_11b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          }
        }

        // Scenario 3 (table): PE scoring system
        if(scenario===3){
          if(!isCalc){
            const press = rng.int(8,20);
            const squats = rng.int(10,25);
            const sets = rng.int(2,6);
            const bonus = rng.int(2,10);

            const rows = [
              {name:"Press-ups per set", val:mml(mmn(press))},
              {name:"Squats per set", val:mml(mmn(squats))},
              {name:"Sets", val:mml(mmn(sets))},
              {name:"Bonus points", val:mml(mmn(bonus))}
            ];

            const intro =
              `A PE teacher uses a scoring system for a workout.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            const aCore = mrowN(mmt("press-ups per set"), mmo("×"), mmt("sets"));
            const aExpr = withBrackets
              ? mml(mrowN(mfencedN(aCore), mmo("−"), mmt("bonus points")))
              : mml(mrowN(aCore, mmo("−"), mmt("bonus points")));

            const bCore = mrowN(
              mmt("squats per set"), mmo("×"), mmt("sets"),
              mmo("+"),
              msupN(mmt("bonus points"), 2),
              mmo("−"),
              mmt("press-ups per set")
            );
            const bExpr = withBrackets
              ? mml(mrowN(
                  mfencedN(mrowN(mmt("squats per set"), mmo("×"), mmt("sets"))),
                  mmo("+"),
                  msupN(mmt("bonus points"), 2),
                  mmo("−"),
                  mmt("press-ups per set")
                ))
              : mml(bCore);

            const aAns = press*sets - bonus;
            const bAns = (squats*sets) + (bonus*bonus) - press;

            return Q([
              makePart("n10_12a", intro + workOutLine("(a) ", aExpr, 1), 1, aAns),
              makePart("n10_12b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          } else {
            const press = dec(8,20,1);
            const squats = dec(10,30,2);
            const sets = dec(2,6,1);
            const bonus = dec(2,6,1);

            const rows = [
              {name:"Press-ups per set", val:mml(mmn(press.s))},
              {name:"Squats per set", val:mml(mmn(squats.s))},
              {name:"Sets", val:mml(mmn(sets.s))},
              {name:"Bonus points", val:mml(mmn(bonus.s))}
            ];

            const intro =
              `A PE teacher uses a scoring system for a workout.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            const aCore = mrowN(mmt("press-ups per set"), mmo("×"), mmt("sets"));
            const aExpr = withBrackets
              ? mml(mrowN(mfencedN(aCore), mmo("−"), mmt("bonus points")))
              : mml(mrowN(aCore, mmo("−"), mmt("bonus points")));

            const bCore = mrowN(
              mmt("squats per set"), mmo("×"), mmt("sets"),
              mmo("+"),
              msupN(mmt("bonus points"), 2),
              mmo("−"),
              mmt("press-ups per set")
            );
            const bExpr = withBrackets
              ? mml(mrowN(
                  mfencedN(mrowN(mmt("squats per set"), mmo("×"), mmt("sets"))),
                  mmo("+"),
                  msupN(mmt("bonus points"), 2),
                  mmo("−"),
                  mmt("press-ups per set")
                ))
              : mml(bCore);

            const aAns = press.v*sets.v - bonus.v;
            const bAns = (squats.v*sets.v) + (bonus.v*bonus.v) - press.v;

            return Q([
              makePart("n10_12a", intro + workOutLine("(a) ", aExpr, 1), 1, aAns),
              makePart("n10_12b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          }
        }
      }

      /* -------------------- 5 MARK (table + parts a/b) -------------------- */
      if(marksTotal===5){
        const scenario = rng.int(1,3);

        // Scenario 1 (money table + CUBING) — brackets needed in (a)
        if(scenario===1){
          if(!isCalc){
            const ticket = rng.int(6,15);
            const premium = rng.int(1,6);
            const booking = rng.int(1,6);
            const voucher = rng.int(1,20);
            const group = rng.int(2,8);
            const service = rng.int(2,5);

            const rows = [
              {name:"Ticket price", val:mml(mmn(ticket))},
              {name:"Premium extra", val:mml(mmn(premium))},
              {name:"Booking fee", val:mml(mmn(booking))},
              {name:"Voucher discount", val:mml(mmn(voucher))},
              {name:"Group size", val:mml(mmn(group))},
              {name:"Service charge", val:mml(mmn(service))}
            ];

            const intro =
              `A cinema offers premium seats.<br>`+
              `There are also booking fees and discounts.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            // (a) [2] 3 ops: (ticket + premium) × group + booking
            const aExpr = mml(mrowN(
              mfencedN(mrowN(mmt("ticket price"), mmo("+"), mmt("premium extra"))),
              mmo("×"),
              mmt("group size"),
              mmo("+"),
              mmt("booking fee")
            ));

            // (b) [3] 4 ops max: service³ + ticket×group − voucher  (NO double brackets)
            const serviceCube = msupN(mmt("service charge"), 3);
            const bExpr = mml(mrowN(
              serviceCube,
              mmo("+"),
              mmt("ticket price"), mmo("×"), mmt("group size"),
              mmo("−"),
              mmt("voucher discount")
            ));

            const aAns = (ticket + premium)*group + booking;
            const bAns = (service*service*service + (ticket*group)) - voucher;

            return Q([
              makePart("n10_13a", intro + workOutLine("(a) ", aExpr, 2), 2, aAns),
              makePart("n10_13b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          } else {
            const ticket = dec(6,15,2);
            const premium = dec(1,6,2);
            const booking = dec(1,6,2);
            const voucher = dec(1,15,2);
            const group = dec(2,8,1);
            const service = dec(1.5,4.5,2);

            const rows = [
              {name:"Ticket price", val:mml(mmn(ticket.s))},
              {name:"Premium extra", val:mml(mmn(premium.s))},
              {name:"Booking fee", val:mml(mmn(booking.s))},
              {name:"Voucher discount", val:mml(mmn(voucher.s))},
              {name:"Group size", val:mml(mmn(group.s))},
              {name:"Service charge", val:mml(mmn(service.s))}
            ];

            const intro =
              `A cinema offers premium seats.<br>`+
              `There are also booking fees and discounts.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            const aExpr = mml(mrowN(
              mfencedN(mrowN(mmt("ticket price"), mmo("+"), mmt("premium extra"))),
              mmo("×"),
              mmt("group size"),
              mmo("+"),
              mmt("booking fee")
            ));

            const serviceCube = msupN(mmt("service charge"), 3);
            const bExpr = mml(mrowN(
              serviceCube,
              mmo("+"),
              mmt("ticket price"), mmo("×"), mmt("group size"),
              mmo("−"),
              mmt("voucher discount")
            ));

            const aAns = (ticket.v + premium.v)*group.v + booking.v;
            const bAns = (service.v**3 + (ticket.v*group.v)) - voucher.v;

            return Q([
              makePart("n10_13a", intro + workOutLine("(a) ", aExpr, 2), 2, aAns),
              makePart("n10_13b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          }
        }

        // Scenario 2 (table + CUBE ROOTING) — MIX brackets 50% (overall mark-5 mix stays ~50/50)
        if(scenario===2){
          const withBrackets = coin();
          if(!isCalc){
            const start = -rng.int(2,10);
            const rise = rng.int(5,12);
            const fall = rng.int(2,10);
            const extra = rng.int(1,6);
            const hours = rng.int(2,6);
            const sensorCubes = [8,27,64,125,216,343];
            const sensor = rng.choice(sensorCubes);
            const sensorRoot = Math.round(Math.cbrt(sensor));

            const rows = [
              {name:"Start", val:mml(mmn(start))},
              {name:"Rise", val:mml(mmn(rise))},
              {name:"Fall", val:mml(mmn(fall))},
              {name:"Extra drop", val:mml(mmn(extra))},
              {name:"Hours", val:mml(mmn(hours))},
              {name:"Sensor check", val:mml(mmn(sensor))}
            ];

            const intro =
              `A weather station models temperature changes.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            // (a) [2] 3 ops
            const aExpr = withBrackets
              ? mml(mrowN(mfencedN(mrowN(mmt("start"), mmo("+"), mmt("rise"))), mmo("−"), mmt("fall"), mmo("−"), mmt("extra drop")))
              : mml(mrowN(mmt("start"), mmo("+"), mmt("rise"), mmo("−"), mmt("fall"), mmo("−"), mmt("extra drop")));

            // (b) [3] 4 ops max
            const riseHours = mrowN(mmt("rise"), mmo("×"), mmt("hours"));
            const cbrt = mrootN(mmt("sensor check"), mmn(3));
            const bExpr = withBrackets
              ? mml(mrowN(mfencedN(riseHours), mmo("+"), cbrt, mmo("−"), mmt("fall")))
              : mml(mrowN(riseHours, mmo("+"), cbrt, mmo("−"), mmt("fall")));

            const aAns = start + rise - fall - extra;
            const bAns = (rise*hours) + sensorRoot - fall;

            return Q([
              makePart("n10_14a", intro + workOutLine("(a) ", aExpr, 2), 2, aAns),
              makePart("n10_14b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          } else {
            const startRaw = dec(2,10,1);
            const start = {v: -startRaw.v, s: ("-" + startRaw.s)};
            const rise = dec(5,12,2);
            const fall = dec(2,10,2);
            const extra = dec(1,6,2);
            const hours = dec(2,6,1);

            const sensor = cubeFromRoot(2.5, 6.5, 1); // gives radStr with 3 dp
            const sensorVal = {v: sensor.rad, s: sensor.radStr};

            const rows = [
              {name:"Start", val:mml(mmn(start.s))},
              {name:"Rise", val:mml(mmn(rise.s))},
              {name:"Fall", val:mml(mmn(fall.s))},
              {name:"Extra drop", val:mml(mmn(extra.s))},
              {name:"Hours", val:mml(mmn(hours.s))},
              {name:"Sensor check", val:mml(mmn(sensorVal.s))}
            ];

            const intro =
              `A weather station models temperature changes.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            const aExpr = withBrackets
              ? mml(mrowN(mfencedN(mrowN(mmt("start"), mmo("+"), mmt("rise"))), mmo("−"), mmt("fall"), mmo("−"), mmt("extra drop")))
              : mml(mrowN(mmt("start"), mmo("+"), mmt("rise"), mmo("−"), mmt("fall"), mmo("−"), mmt("extra drop")));

            const riseHours = mrowN(mmt("rise"), mmo("×"), mmt("hours"));
            const cbrt = mrootN(mmt("sensor check"), mmn(3));
            const bExpr = withBrackets
              ? mml(mrowN(mfencedN(riseHours), mmo("+"), cbrt, mmo("−"), mmt("fall")))
              : mml(mrowN(riseHours, mmo("+"), cbrt, mmo("−"), mmt("fall")));

            const aAns = start.v + rise.v - fall.v - extra.v;
            const bAns = (rise.v*hours.v) + sensor.root - fall.v;

            return Q([
              makePart("n10_14a", intro + workOutLine("(a) ", aExpr, 2), 2, aAns),
              makePart("n10_14b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          }
        }

        // Scenario 3 (table + SQRT + SQUARING) — NO brackets (keeps overall mix balanced)
        if(scenario===3){
          if(!isCalc){
            const pA = rng.int(2,6);
            const hA = rng.int(2,8);
            const pB = rng.int(2,6);
            const hB = rng.int(2,10);
            const saved = rng.int(1,10);
            const meterSquares = [25,36,49,64,81,100,121,144,169,196];
            const meter = rng.choice(meterSquares);
            const loss = rng.int(2,8);

            const rows = [
              {name:"Power A", val:mml(mmn(pA))},
              {name:"Hours A", val:mml(mmn(hA))},
              {name:"Power B", val:mml(mmn(pB))},
              {name:"Hours B", val:mml(mmn(hB))},
              {name:"Saved energy", val:mml(mmn(saved))},
              {name:"Meter reading", val:mml(mmn(meter))},
              {name:"Loss factor", val:mml(mmn(loss))}
            ];

            const intro =
              `An engineer models energy use from two devices.<br>`+
              `A meter reading is also included.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            // (a) [2] 3 ops: powerA×hoursA + √(meter)
            const aExpr = mml(mrowN(
              mmt("power A"), mmo("×"), mmt("hours A"),
              mmo("+"),
              msqrtN(mmt("meter reading"))
            ));

            // (b) [3] 4 ops: powerB×hoursB − saved + loss²
            const bExpr = mml(mrowN(
              mmt("power B"), mmo("×"), mmt("hours B"),
              mmo("−"),
              mmt("saved energy"),
              mmo("+"),
              msupN(mmt("loss factor"), 2)
            ));

            const aAns = (pA*hA) + Math.sqrt(meter);
            const bAns = (pB*hB) - saved + (loss*loss);

            return Q([
              makePart("n10_15a", intro + workOutLine("(a) ", aExpr, 2), 2, aAns),
              makePart("n10_15b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          } else {
            const pA = dec(2,6,2);
            const hA = dec(2,8,1);
            const pB = dec(2,6,2);
            const hB = dec(2,10,1);
            const saved = dec(1,10,2);

            const sq = squareFromRoot(6,14,1); // exact square like 84.64
            const meter = {v: sq.rad, s: sq.radStr};

            const loss = dec(2,8,1);

            const rows = [
              {name:"Power A", val:mml(mmn(pA.s))},
              {name:"Hours A", val:mml(mmn(hA.s))},
              {name:"Power B", val:mml(mmn(pB.s))},
              {name:"Hours B", val:mml(mmn(hB.s))},
              {name:"Saved energy", val:mml(mmn(saved.s))},
              {name:"Meter reading", val:mml(mmn(meter.s))},
              {name:"Loss factor", val:mml(mmn(loss.s))}
            ];

            const intro =
              `An engineer models energy use from two devices.<br>`+
              `A meter reading is also included.<br>`+
              `The values are shown in the table.<div style="height:8px"></div>`+
              tableHtml(rows) +
              `<div style="height:8px"></div>`;

            const aExpr = mml(mrowN(
              mmt("power A"), mmo("×"), mmt("hours A"),
              mmo("+"),
              msqrtN(mmt("meter reading"))
            ));

            const bExpr = mml(mrowN(
              mmt("power B"), mmo("×"), mmt("hours B"),
              mmo("−"),
              mmt("saved energy"),
              mmo("+"),
              msupN(mmt("loss factor"), 2)
            ));

            const aAns = (pA.v*hA.v) + sq.root;
            const bAns = (pB.v*hB.v) - saved.v + (loss.v*loss.v);

            return Q([
              makePart("n10_15a", intro + workOutLine("(a) ", aExpr, 2), 2, aAns),
              makePart("n10_15b", workOutLine("(b) ", bExpr, 3), 3, bAns),
            ]);
          }
        }
      }

      // Fallback (should never hit)
      return Q([makePart("n10_x", `Not implemented. <span class="endmark">[${marksTotal}]</span>`, marksTotal, 0)]);
    }
    case "N11": {
      // CHANGE REQUEST #6 (N11): 1–2 mark questions must use a two-step number machine.
      // Number machine rules enforced:
      // - Exactly TWO operations.
      // - Operation 1 is add or subtract.
      // - Operation 2 is multiply or divide.
      // - Integers only for inputs/outputs.
      const makeNumberMachine = (easy=true)=>{
        const op1 = rng.choice(["+","-"]);
        const op2 = rng.choice(["×","÷"]);
        const n1 = rng.int(2, easy ? 9 : 25);
        const n2 = rng.int(2, easy ? 6 : 12);
        let input=1, after1=1, output=1;
        for(let tries=0; tries<200; tries++){
          if(op2 === "×"){
            input = rng.int(3, easy ? 25 : 60);
            if(op1 === "-" && input <= n1) continue;
            after1 = (op1 === "+") ? (input + n1) : (input - n1);
            output = after1 * n2;
          } else {
            output = rng.int(2, easy ? 20 : 50);
            after1 = output * n2;
            input = (op1 === "+") ? (after1 - n1) : (after1 + n1);
            if(input <= 0) continue;
          }
          if(Number.isInteger(input) && Number.isInteger(after1) && Number.isInteger(output)) break;
        }
        const op1Text = `${op1} ${n1}`;
        const op2Text = `${op2} ${n2}`;
        return {op1, op2, n1, n2, input, after1, output, op1Text, op2Text};
      };

      if(marksTotal===1){
        const nm = makeNumberMachine(true);
        return Q([
          partInteger(
            "n11_1",
            `A number machine does two steps:<br><b>${nm.input}</b> &rarr; <b>${nm.op1Text}</b> &rarr; <b>${nm.op2Text}</b> &rarr; output.<br>Work out the <b>output</b>. <span class="endmark">[1]</span>`,
            1,
            nm.output
          )
        ]);
      }
      if(marksTotal===2){
        const nm = makeNumberMachine(false);
        return Q([
          partInteger(
            "n11_2a",
            `A number machine does two steps:<br><b>${nm.input}</b> &rarr; <b>${nm.op1Text}</b> &rarr; <b>${nm.op2Text}</b> &rarr; output.<br>What number comes out after the <b>first</b> step? <span class="endmark">[1]</span>`,
            1,
            nm.after1
          ),
          partInteger(
            "n11_2b",
            `What is the <b>final output</b>? <span class="endmark">[1]</span>`,
            1,
            nm.output
          )
        ]);
      }
      if(marksTotal===3){
        const x = rng.int(10,50);
        const m = rng.int(3,9);
        const c = rng.int(2,20);
        return Q([
          partInteger("n11_3a", `Find <b>x</b>: <b>${m}x = ${m*x}</b>. <span class="endmark">[2]</span>`, 2, x),
          partInteger("n11_3b", `Using your value of <b>x</b>, find <b>y</b> if <b>y − x = ${c}</b>. <span class="endmark">[1]</span>`, 1, x + c),
        ]);
      }
      if(marksTotal===4){
        const a = rng.int(20,60), b = rng.int(2,12), c = rng.int(5,25);
        // (x + a) ÷ b = c  => x = bc - a
        const x = b*c - a;
        return Q([partInteger("n11_4", `Solve: <b>(x + ${a}) ÷ ${b} = ${c}</b>. <span class="endmark">[4]</span>`, 4, x)]);
      }
      // 5 marks
      const mult = rng.choice([6,7,8,9,12,15]);
      const x = rng.int(11,60);
      const total = mult*x;
      return Q([
        partInteger("n11_5a", `A number is multiplied by <b>${mult}</b> to give <b>${total}</b>. Work out the original number. <span class="endmark">[3]</span>`, 3, x),
        partInteger("n11_5b", `Now work out: <b>${x} + ${mult}</b>. <span class="endmark">[2]</span>`, 2, x+mult),
      ]);
    }
    case "N12": {
      if(marksTotal===1){
        const n=rng.choice([24,30,36,40,42,45,48,50,54,56,60]);
        const f=rng.choice([2,3,4,5,6,7,8,9,10,12]);
        const ans = (n%f===0) ? 1 : 0;
        return Q([partInteger("n12_1", `Write <b>1</b> if <b>${n}</b> is a multiple of <b>${f}</b>, otherwise write <b>0</b>. <span class="endmark">[1]</span>`, 1, ans)]);
      }
      if(marksTotal===2){
        const n=rng.choice([24,30,36,40,42,45,48,50,54,56,60,72,84,90]);
        let count=0;
        for(let i=1;i<=n;i++) if(n%i===0) count++;
        return Q([partInteger("n12_2", `How many factors does <b>${n}</b> have? <span class="endmark">[2]</span>`, 2, count)]);
      }
      if(marksTotal===3){
        const a=rng.int(12,60), b=rng.int(12,60);
        const g=gcd(a,b);
        const common = [];
        for(let i=1;i<=g;i++) if(g%i===0) common.push(i);
        const largest = common[common.length-1];
        return Q([
          partInteger("n12_3a", `Find a common factor of <b>${a}</b> and <b>${b}</b>. (give the greatest) <span class="endmark">[2]</span>`, 2, largest),
          partInteger("n12_3b", `How many common factors do they have? <span class="endmark">[1]</span>`, 1, common.length),
        ]);
      }
      if(marksTotal===4){
        const n = rng.choice([30,36,40,42,48,54,56,60,66,70,72,84,90]);
        // ask: list two factors in a range
        const factors=[];
        for(let i=1;i<=n;i++) if(n%i===0) factors.push(i);
        const mid = factors.filter(x=>x>5 && x<30);
        const a = mid[0], b = mid[mid.length-1];
        return Q([
          partInteger("n12_4a", `Write a factor of <b>${n}</b> that is <b>between 5 and 30</b>. (smallest possible) <span class="endmark">[2]</span>`, 2, a),
          partInteger("n12_4b", `Write another factor of <b>${n}</b> that is <b>between 5 and 30</b>. (largest possible) <span class="endmark">[2]</span>`, 2, b),
        ]);
      }
      // 5 marks: find number given conditions (single topic: factors/multiples)
      const base = rng.choice([6,8,9,10,12,14,15]);
      const k = rng.int(4,10);
      const n = base*k;
      const cond1 = `multiple of <b>${base}</b>`;
      const cond2 = `between <b>${base*k-5}</b> and <b>${base*k+5}</b>`;
      const cond3 = `not a multiple of <b>${base*2}</b>`;
      // choose n that violates? ensure not multiple of 2*base by making k odd when 2*base divides n if k even.
      let kk = k;
      if(kk%2===0) kk+=1;
      const nn = base*kk;
      return Q([
        partInteger("n12_5", `Find an integer that is a ${cond1}, is ${cond2}, and is ${cond3}. <span class="endmark">[5]</span>`, 5, nn)
      ]);
    }
    /* SPLITMERGE:BUILDQUESTION-CASES-END */

    default:
      return Q([partNumber("x", `Not implemented. <span class="endmark">[${marksTotal}]</span>`, marksTotal, 0)]);
  }
}

// SECTION: Rendering + inputs
// - Builds the per-question HTML (question text, answer inputs, mark buttons).
// - Installs widget behaviour for:
//   • standard form EXP entry (single input)
//   • drag-and-drop ordering tiles
//   • numeric/text answer validation
const topicSel = document.getElementById("topicSel");
const marksSel = document.getElementById("marksSel");
const calcSel  = document.getElementById("calcSel");
const preview  = document.getElementById("preview");
const fb       = document.getElementById("fb");

const regenBtn = document.getElementById("regenBtn");
const checkBtn = document.getElementById("checkBtn");
const revealBtn= document.getElementById("revealBtn");

let current = null;

function initTopicDropdown(){
  TOPICS.forEach(t=>{
    const o=document.createElement("option");
    o.value=t.code;
    o.textContent=`${t.code} — ${t.name}`;
    topicSel.appendChild(o);
  });
  topicSel.value = "N10"; // default: simplify fractions (a commonly tested topic)
}

function paperTagHtml(paperMode){
  return paperMode==="calc"
    ? `<span class="nc-tag calc">CALCULATOR</span>`
    : `<span class="nc-tag nc">NON‑CALCULATOR</span>`;
}

function renderInput(input, answerType, baseId){
  if (!input) return "";
  const kind = input.kind;

  if (kind==="fraction" || answerType==="fraction"){
    return `
      <span class="frac" aria-label="fraction answer">
        <input id="${baseId}N" class="mini" type="text" inputmode="numeric" placeholder="numerator" />
        <span class="bar"></span>
        <input id="${baseId}D" class="mini" type="text" inputmode="numeric" placeholder="denominator" />
      </span>
    `;
  }

  if (kind==="pair"){
    const lab0 = input.labels?.[0];
    const lab1 = input.labels?.[1];
    const ph0 = input.placeholders?.[0]||"a";
    const ph1 = input.placeholders?.[1]||"b";
    const labelHtml = (t)=> t ? `<span style="font-weight:900;color:#111827">${t}</span>` : "";
    return `
      <span class="twobox" aria-label="two answers">
        ${labelHtml(lab0)}
        <input id="${baseId}A" class="mini" type="text" inputmode="decimal" placeholder="${ph0}" />
        ${labelHtml(lab1)}
        <input id="${baseId}B" class="mini" type="text" inputmode="decimal" placeholder="${ph1}" />
      </span>
    `;
  }

  if (kind==="triple"){
    return `
      <span class="threebox" aria-label="three answers">
        <input id="${baseId}A" class="mini" type="text" inputmode="decimal" placeholder="${input.placeholders?.[0]||"a"}" />
        <input id="${baseId}B" class="mini" type="text" inputmode="decimal" placeholder="${input.placeholders?.[1]||"b"}" />
        <input id="${baseId}C" class="mini" type="text" inputmode="decimal" placeholder="${input.placeholders?.[2]||"c"}" />
      </span>
    `;
  }

  if (kind==="standardForm" || answerType==="standardForm"){
    // Single entry box only. Press EXP to insert ×10 and then type the power as a superscript.
    return `
      <div class="sfwrap" aria-label="standard form answer">
        <input id="${baseId}" class="sfinput" type="text" inputmode="decimal" placeholder="e.g. 3.2×10⁵" autocomplete="off" />
        <div class="keypad sfctrl" data-sf-target="${baseId}">
          <button class="kbtn accent" data-act="exp">EXP</button>
          <button class="kbtn" data-act="neg">±</button>
          <button class="kbtn" data-act="bksp">⌫</button>
          <button class="kbtn" data-act="clear">Clear</button>
        </div>
        <div class="sfhint">Type the number. Press <b>EXP</b> to insert <b>×10</b> with a superscript power.</div>
      </div>
    `;
  }


  if (kind==="primeFactors" || answerType==="primeFactors"){
    // Visual box + hidden canonical string (uses ^ internally, never shown)
    return `
      <div class="pfwrap" aria-label="prime factorisation answer">
        <div class="pfbox" id="${baseId}Box" tabindex="0" aria-label="prime factorisation input"></div>
        <input id="${baseId}" type="hidden" value="" />
        <div class="keypad" data-target="${baseId}" data-exp="0">
          <button class="kbtn" data-prime="2">2</button>
          <button class="kbtn" data-prime="3">3</button>
          <button class="kbtn" data-prime="5">5</button>
          <button class="kbtn" data-prime="7">7</button>
          <button class="kbtn" data-prime="11">11</button>
          <button class="kbtn primary" data-ins="×">×</button>

          <button class="kbtn" data-act="exp" aria-pressed="false">EXP</button>
          <button class="kbtn" data-digit="1">1</button>
          <button class="kbtn" data-digit="2">2</button>
          <button class="kbtn" data-digit="3">3</button>
          <button class="kbtn" data-digit="4">4</button>
          <button class="kbtn" data-digit="5">5</button>

          <button class="kbtn" data-digit="6">6</button>
          <button class="kbtn" data-digit="7">7</button>
          <button class="kbtn" data-digit="8">8</button>
          <button class="kbtn" data-digit="9">9</button>
          <button class="kbtn" data-digit="0">0</button>
          <button class="kbtn" data-act="bksp">⌫</button>

          <button class="kbtn danger" data-act="clear" style="grid-column:1 / span 6">Clear</button>
        </div>
      </div>
    `;
  }

  

  if (kind==="order" || answerType==="order"){
    // Drag-order widgets render inside the question text; nothing to render here.
    return ``;
  }
if (kind==="money"){
    return `<input id="${baseId}" type="text" inputmode="decimal" placeholder="£" style="min-width:140px" />`;
  }

  if (kind==="int" || kind==="integer"){

    return `<input id="${baseId}" type="text" inputmode="numeric" placeholder="answer" style="min-width:140px" />`;
  }

  return `<input id="${baseId}" type="text" inputmode="decimal" placeholder="answer" style="min-width:160px" />`;
}

function renderQuestion(q){
  const topicName = TOPICS.find(t=>t.code===q.topicCode)?.name ?? q.topicCode;
  const title = `${q.topicCode} — ${topicName}`;
  const badge = `<span class="badge">[${q.marksTotal} mark${q.marksTotal===1?"":"s"}]</span>`;

  const itemsHtml = q.parts.map((p,idx)=>{
    const inputHtml = renderInput(p.input, p.answer?.type, p.input?.id || `p${idx}`);
    let html = (p.textHtml ?? "");
    let side = inputHtml;

    // If the question text contains an inline input placeholder, inject the input there
    // and do not render the separate right-hand column input.
    if(typeof html === "string" && html.includes("{{INPUT}}")){
      html = html.replace("{{INPUT}}", inputHtml);
      side = "";
    }

    return `
      <div class="item">
        <div class="line">
          <div class="qtext">${html}</div>
          ${side ? `<div>${side}</div>` : ``}
        </div>
      </div>
    `;
  }).join("");

  preview.innerHTML = `
    <div class="qpanel">
      <div class="qhead">
        <h3>${title} ${badge}</h3>
        ${paperTagHtml(q.paperMode)}
      </div>
      <div class="qbody">
        ${itemsHtml}
      </div>
    </div>
  `;

  initDragOrders();

  fb.style.display="none";
  fb.className="feedback";
  fb.textContent="";
}


// SECTION: Drag-and-drop ordering (integers/decimals/fractions)
// - Tiles can be dragged from the bank into drop boxes.
// - The student's order is stored as JSON in a hidden <input>.
// - Check logic reads and compares the stored order to the expected token list.
let dragState = {box:null, widget:null};
let clickPick = null;

function syncDragOrder(widget){
  if(!widget) return;
  const hidden = widget.querySelector('input[type="hidden"]');
  const drops = Array.from(widget.querySelectorAll(".dropbox"));
  const arr = drops.map(d=>d.querySelector(".dragbox")?.dataset.token ?? null);
  if(hidden) hidden.value = JSON.stringify(arr);
}

function initDragOrders(){
  if(clickPick && clickPick.classList) clickPick.classList.remove("selected");
  clickPick = null;
  preview.querySelectorAll(".drag-order").forEach(w=>syncDragOrder(w));
}

function placeDragBox(box, target){
  if(!box || !target) return;
  const widget = box.closest(".drag-order");
  if(!widget) return;
  const bank = widget.querySelector(".drag-bank");
  if(!bank) return;

  if(target.classList.contains("dropbox")){
    const existing = target.querySelector(".dragbox");
    const srcParent = box.parentElement;
    if(existing && existing!==box){
      if(srcParent && srcParent.classList.contains("dropbox")){
        srcParent.appendChild(existing);
      } else {
        bank.appendChild(existing);
      }
    }
    target.appendChild(box);
  } else if(target.classList.contains("drag-bank")){
    target.appendChild(box);
  }
  syncDragOrder(widget);
}

preview.addEventListener("dragstart", (e)=>{
  const box = e.target.closest(".dragbox");
  if(!box) return;
  const widget = box.closest(".drag-order");
  if(!widget) return;
  dragState.box = box;
  dragState.widget = widget;
  box.classList.add("dragging");
  try{
    e.dataTransfer.setData("text/plain", box.dataset.token || box.textContent || "");
    e.dataTransfer.effectAllowed = "move";
  }catch(err){}
});

preview.addEventListener("dragend", (e)=>{
  const box = e.target.closest(".dragbox");
  if(box) box.classList.remove("dragging");
  preview.querySelectorAll(".dropbox.over").forEach(el=>el.classList.remove("over"));
  dragState.box = null;
  dragState.widget = null;
});

preview.addEventListener("dragover", (e)=>{
  const target = e.target.closest(".dropbox, .drag-bank");
  if(!target) return;
  const widget = target.closest(".drag-order");
  if(!widget || widget !== dragState.widget) return;
  e.preventDefault();
  if(target.classList.contains("dropbox")) target.classList.add("over");
});

preview.addEventListener("dragleave", (e)=>{
  const target = e.target.closest(".dropbox");
  if(target) target.classList.remove("over");
});

preview.addEventListener("drop", (e)=>{
  const target = e.target.closest(".dropbox, .drag-bank");
  if(!target) return;
  const widget = target.closest(".drag-order");
  if(!widget || widget !== dragState.widget) return;
  e.preventDefault();
  target.classList.remove("over");
  if(dragState.box){
    placeDragBox(dragState.box, target);
  }
});

// Tap/click fallback (mobile): tap a box to pick it up, then tap a target.
preview.addEventListener("click", (e)=>{
  const box = e.target.closest(".dragbox");
  const widget = e.target.closest(".drag-order");
  if(box && widget){
    if(clickPick === box){
      box.classList.remove("selected");
      clickPick = null;
    } else {
      if(clickPick) clickPick.classList.remove("selected");
      clickPick = box;
      box.classList.add("selected");
    }
    return;
  }

  const target = e.target.closest(".dropbox, .drag-bank");
  if(target && clickPick){
    const w2 = target.closest(".drag-order");
    const w1 = clickPick.closest(".drag-order");
    if(w1 && w2 && w1===w2){
      placeDragBox(clickPick, target);
    }
    clickPick.classList.remove("selected");
    clickPick = null;
  }
});

/* -------------------- standard form input (EXP -> superscript) -------------------- */
const SF_SUP = {
  "0":"⁰","1":"¹","2":"²","3":"³","4":"⁴","5":"⁵","6":"⁶","7":"⁷","8":"⁸","9":"⁹",
  "-":"⁻","+":"⁺"
};
const SF_UNSUP = {
  "⁰":"0","¹":"1","²":"2","³":"3","⁴":"4","⁵":"5","⁶":"6","⁷":"7","⁸":"8","⁹":"9",
  "⁻":"-","⁺":"+"
};

function sfEscapeHtml(s){
  return String(s??"")
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");
}
function sfUnsupAll(s){
  return String(s??"").replace(/[⁰¹²³⁴⁵⁶⁷⁸⁹⁻⁺]/g, ch => (SF_UNSUP[ch] ?? ch));
}
function sfSupDigits(s){
  return String(s??"").replace(/[0-9\-\+]/g, ch => (SF_SUP[ch] ?? ch));
}

function sfToHTML(raw){
  const s0 = String(raw ?? "").trim();
  if(!s0) return "";
  const plain = sfUnsupAll(s0).replace(/\s+/g,"");

  // Display E-notation as ×10^n.
  let m = plain.match(/^([+-]?(?:\d+(?:\.\d+)?|\.\d+))[eE]([+-]?\d*)$/);
  if(m){
    const A = m[1] ?? "";
    const n = m[2] ?? "";
    return `${sfEscapeHtml(A)}<span class="mul">×</span>10<sup>${sfEscapeHtml(n || "□")}</sup>`;
  }

  // Display A×10n or A×10^n (caret optional)
  m = plain.match(/^([+-]?(?:\d+(?:\.\d+)?|\.\d+))(?:×|x|\*)10\^?([+-]?\d*)$/i);
  if(m){
    const A = m[1] ?? "";
    const n = m[2] ?? "";
    return `${sfEscapeHtml(A)}<span class="mul">×</span>10<sup>${sfEscapeHtml(n || "□")}</sup>`;
  }

  // Fallback: show as typed (still replaces × with styled ×).
  return sfEscapeHtml(s0).replace(/×/g, `<span class="mul">×</span>`);
}

function sfSyncPreview(targetId){
  const el = document.getElementById(targetId);
  const box = document.getElementById(targetId+"Box");
  if(!el || !box) return;
  box.innerHTML = sfToHTML(el.value);
}

function sfSetCaretEnd(el){
  try{
    const n = el.value.length;
    el.setSelectionRange(n, n);
  }catch(err){}
}

function sfEnsureTen(v){
  v = String(v ?? "");
  if(/(?:×|x|\*)10/.test(v)) return v;
  if(v==="" || v==="-") v = (v==="-") ? "-1" : "1";
  return v + "×10";
}

function sfGetExpPart(v){
  const m = String(v ?? "").match(/(?:×|x|\*)10(.*)$/);
  return m ? (m[1] ?? "") : "";
}

function sfToggleMantissaSign(v){
  v = String(v ?? "");
  if(v.startsWith("-")) return v.slice(1);
  return v ? "-" + v : "-";
}

function sfToggleExponentSign(v){
  v = String(v ?? "");
  const m = v.match(/^(.*?)(?:×|x|\*)10(.*)$/);
  if(!m) return sfToggleMantissaSign(v);

  const head = m[1] ?? "";
  const expRaw = m[2] ?? "";
  const expPlain = sfUnsupAll(expRaw);

  let outPlain = expPlain;
  if(outPlain.startsWith("-")) outPlain = outPlain.slice(1);
  else outPlain = "-" + outPlain.replace(/^\+/, "");

  const outSup = sfSupDigits(outPlain);
  return head + "×10" + outSup;
}

function sfBackspace(v){
  v = String(v ?? "");
  if(!v) return "";

  const last = v.slice(-1);
  if(typeof SF_UNSUP[last] !== "undefined"){
    // delete superscript digit/sign
    v = v.slice(0,-1);
    return v;
  }

  if(v.endsWith("×10")) return v.slice(0,-3);
  return v.slice(0,-1);
}

// Keep the preview in sync while typing
preview.addEventListener("input", (e)=>{
  const el = e.target;
  if(!(el instanceof HTMLInputElement)) return;
  if(!el.classList.contains("sfinput")) return;

  // If the user deletes the ×10 part, cancel EXP mode
  if(el.dataset.sfExp === "1" && !/(?:×|x|\*)10/.test(el.value)){
    el.dataset.sfExp = "0";
    const ctrl = preview.querySelector(`.sfctrl[data-sf-target="${el.id}"]`);
    const expBtn = ctrl ? ctrl.querySelector('button[data-act="exp"]') : null;
    if(expBtn){
      expBtn.classList.remove("on");
      expBtn.setAttribute("aria-pressed","false");
    }
  }

  sfSyncPreview(el.id);
});

// Keyboard typing: when EXP is ON, digits become superscripts (no E and no caret notation).
preview.addEventListener("keydown", (e)=>{
  const el = e.target;
  if(!(el instanceof HTMLInputElement)) return;
  if(!el.classList.contains("sfinput")) return;
  if(el.dataset.sfExp !== "1") return;

  const key = e.key;

  // Always keep typing at the end while EXP is on
  if(key==="ArrowLeft" || key==="ArrowRight" || key==="Home" || key==="End"){
    e.preventDefault();
    sfSetCaretEnd(el);
    return;
  }

  if(key==="Backspace"){
    e.preventDefault();
    const nv = sfBackspace(el.value);
    el.value = nv;
    sfSyncPreview(el.id);
    sfSetCaretEnd(el);

    // If we removed the ×10 part, also turn EXP off
    if(!/(?:×|x|\*)10/.test(el.value)){
      el.dataset.sfExp = "0";
      const ctrl = preview.querySelector(`.sfctrl[data-sf-target="${el.id}"]`);
      const expBtn = ctrl ? ctrl.querySelector('button[data-act="exp"]') : null;
      if(expBtn){
        expBtn.classList.remove("on");
        expBtn.setAttribute("aria-pressed","false");
      }
    }
    return;
  }

  if(/^[0-9]$/.test(key) || key==="-" || key==="+"){
    e.preventDefault();
    let v = sfEnsureTen(el.value);

    const expRaw = sfGetExpPart(v);
    const expPlain = sfUnsupAll(expRaw);

    // Only allow +/− as the FIRST exponent character
    if((key==="-" || key==="+") && expPlain.length>0) return;

    v += SF_SUP[key] ?? key;
    el.value = v;
    sfSyncPreview(el.id);
    sfSetCaretEnd(el);
    return;
  }
});

// Buttons (EXP / ± / ⌫ / Clear)
preview.addEventListener("click", (e)=>{
  const btn = e.target.closest("button");
  if(!btn) return;

  const ctrl = btn.closest(".sfctrl");
  if(!ctrl) return;

  e.preventDefault();

  const targetId = ctrl.dataset.sfTarget;
  const el = document.getElementById(targetId);
  if(!el) return;

  const act = btn.dataset.act;

  if(act==="clear"){
    el.value = "";
    el.dataset.sfExp = "0";
    btn.classList.remove("on");
    btn.setAttribute("aria-pressed","false");
    sfSyncPreview(targetId);
    el.focus();
    return;
  }

  if(act==="bksp"){
    const nv = sfBackspace(el.value);
    el.value = nv;
    sfSyncPreview(targetId);
    sfSetCaretEnd(el);

    if(!/(?:×|x|\*)10/.test(el.value)){
      el.dataset.sfExp = "0";
      const expBtn = ctrl.querySelector('button[data-act="exp"]');
      if(expBtn){
        expBtn.classList.remove("on");
        expBtn.setAttribute("aria-pressed","false");
      }
    }

    el.focus();
    return;
  }

  if(act==="exp"){
    const expBtn = ctrl.querySelector('button[data-act="exp"]');
    const on = !(el.dataset.sfExp === "1");
    el.dataset.sfExp = on ? "1" : "0";
    if(expBtn){
      expBtn.classList.toggle("on", on);
      expBtn.setAttribute("aria-pressed", on ? "true" : "false");
    }

    if(on){
      el.value = sfEnsureTen(el.value);
      // Do NOT insert ^ or E. Exponent digits will be added as superscripts.
      sfSetCaretEnd(el);
    }

    sfSyncPreview(targetId);
    el.focus();
    return;
  }

  if(act==="neg"){
    // If there is a ×10 part, toggle the exponent sign. Otherwise toggle the mantissa sign.
    if(/(?:×|x|\*)10/.test(el.value)){
      el.value = sfToggleExponentSign(el.value);
    }else{
      el.value = sfToggleMantissaSign(el.value);
    }
    sfSyncPreview(targetId);
    sfSetCaretEnd(el);
    el.focus();
    return;
  }
});

/* -------------------- keypad for prime factors (exp / × / primes) -------------------- */
function pfToHTML(expr){
  if(!expr) return "";
  const parts = String(expr).split("×");
  let out = "";
  for(let i=0;i<parts.length;i++){
    const tok = parts[i];
    if(tok){
      if(tok.includes("^")){
        const [base, exp] = tok.split("^");
        out += `${base}<sup>${exp||""}</sup>`;
      }else{
        out += tok;
      }
    }
    if(i < parts.length-1){
      out += `<span class="mul">×</span>`;
    }
  }
  return out;
}

function pfSetValue(targetId, newVal){
  const hidden = document.getElementById(targetId);
  const box = document.getElementById(targetId+"Box");
  if(!hidden || !box) return;
  hidden.value = newVal;
  box.innerHTML = pfToHTML(newVal);
}

function pfBackspace(expr){
  if(!expr) return "";
  let s = String(expr);
  if(s.endsWith("×")) return s.slice(0,-1);

  const parts = s.split("×");
  if(parts.length===0) return "";
  let last = parts[parts.length-1] || "";

  if(last.includes("^")){
    let [base, exp] = last.split("^");
    exp = exp || "";
    if(exp.length<=1){
      last = base;
    }else{
      last = base + "^" + exp.slice(0,-1);
    }
    parts[parts.length-1] = last;
    return parts.join("×");
  }

  last = last.slice(0,-1);
  if(last===""){
    parts.pop();
    return parts.join("×");
  }
  parts[parts.length-1] = last;
  return parts.join("×");
}

preview.addEventListener("click", (e)=>{
  const btn = e.target.closest("button");
  if(!btn) return;

  const pad = btn.closest(".keypad");
  if(!pad) return;

  e.preventDefault();

  const target = pad.dataset.target;
  const hidden = document.getElementById(target);
  const box = document.getElementById(target+"Box");
  if(!hidden || !box) return;

  const expBtn = pad.querySelector('button[data-act="exp"]');
  const setExp = (on)=>{
    pad.dataset.exp = on ? "1" : "0";
    if(expBtn){
      expBtn.classList.toggle("on", on);
      expBtn.setAttribute("aria-pressed", on ? "true" : "false");
    }
  };

  const isExp = pad.dataset.exp === "1";
  let val = hidden.value || "";

  const act = btn.dataset.act;
  const prime = btn.dataset.prime;
  const digit = btn.dataset.digit;
  const ins = btn.dataset.ins;

  if(act==="clear"){
    pfSetValue(target, "");
    setExp(false);
    return;
  }
  if(act==="bksp"){
    const nv = pfBackspace(val);
    pfSetValue(target, nv);
    // keep exp mode as-is
    return;
  }
  if(act==="exp"){
    if(!val || val.endsWith("×")){ setExp(false); return; }
    setExp(!isExp);
    return;
  }

  if(ins==="×"){
    setExp(false);
    if(!val) return;
    if(val.endsWith("×")) return;
    pfSetValue(target, val + "×");
    return;
  }

  if(prime){
    setExp(false);
    if(val && !val.endsWith("×")) val += "×";
    pfSetValue(target, val + prime);
    return;
  }

  if(typeof digit !== "undefined"){
    if(pad.dataset.exp !== "1") return;
    if(!val || val.endsWith("×")) return;

    const parts = val.split("×");
    let last = parts[parts.length-1] || "";
    if(!last) return;

    let base = last, exp = "";
    if(last.includes("^")){
      [base, exp] = last.split("^");
      exp = exp || "";
    }
    if(exp==="" && digit==="0") return; // no leading zero exponent
    exp += digit;
    parts[parts.length-1] = base + "^" + exp;
    pfSetValue(target, parts.join("×"));
    return;
  }
});

/* -------------------- Answer retrieval -------------------- */
function clearMarks(){
  // remove ok/bad classes from inputs + drag-order tiles
  preview.querySelectorAll("input,select,.dropbox,.dragbox").forEach(el=>{
    el.classList.remove("ok","bad");
  });
}
function markEl(el, ok){
  if(!el) return;
  el.classList.remove("ok","bad");
  el.classList.add(ok ? "ok" : "bad");
}
function getUserAnswerForPart(part){
  const id = part.input?.id;
  const type = part.answer?.type;

  if (part.input?.kind==="order" || type==="order"){
    const hidden = document.getElementById(id);
    const widget = preview.querySelector(`.drag-order[data-drag-order="${id}"]`);
    const drops = widget ? Array.from(widget.querySelectorAll(".dropbox")) : [];

    let arr = null;
    if(hidden && hidden.value){
      try{ arr = JSON.parse(hidden.value); }catch{ arr = null; }
    }
    if(!Array.isArray(arr) && drops.length){
      arr = drops.map(d=>d.querySelector(".dragbox")?.dataset.token ?? null);
    }
    if(!Array.isArray(arr)){
      return {ok:false, val:null, els:drops.length?drops:[hidden].filter(Boolean)};
    }

    const filled = arr.every(x=>x!==null && x!=="" && typeof x!=="undefined");
    return {ok:filled, val:arr, els:drops.length?drops:[hidden].filter(Boolean)};
  }

  if (part.input?.kind==="fraction" || type==="fraction"){
    const nEl = document.getElementById(id+"N");
    const dEl = document.getElementById(id+"D");
    const n = Number(nEl?.value);
    const d = Number(dEl?.value);
    if(!Number.isFinite(n)||!Number.isFinite(d)||d===0) return {ok:false, val:null, els:[nEl,dEl]};
    return {ok:true, val:{n, d}, els:[nEl,dEl]};
  }

  if (part.input?.kind==="pair" || type==="pair"){
    const aEl = document.getElementById(id+"A");
    const bEl = document.getElementById(id+"B");
    const a = asNum(aEl?.value);
    const b = asNum(bEl?.value);
    if(!Number.isFinite(a)||!Number.isFinite(b)) return {ok:false, val:null, els:[aEl,bEl]};
    return {ok:true, val:[a,b], els:[aEl,bEl]};
  }

  if (part.input?.kind==="standardForm" || type==="standardForm"){
    const el = document.getElementById(id);
    const parsed = parseStandardFormInput(el?.value);
    if(!parsed.ok || !Number.isFinite(parsed.A) || !Number.isFinite(parsed.n)) return {ok:false, val:null, els:[el]};
    return {ok:true, val:{A: parsed.A, n: parsed.n}, els:[el]};
  }

  if (part.input?.kind==="primeFactors" || type==="primeFactors"){
    const el = document.getElementById(id);
    const raw = (el?.value ?? "").trim();
    if(!raw) return {ok:false, val:null, els:[el]};
    return {ok:true, val:raw, els:[el]};
  }

  if (part.input?.kind==="symbol" || type==="symbol"){
    const el = document.getElementById(id);
    const v = (el?.value ?? "").trim();
    if(!v) return {ok:false, val:null, els:[el]};
    return {ok:true, val:v, els:[el]};
  }

  if (part.input?.kind==="time" || type==="time"){
    const el = document.getElementById(id);
    const v = (el?.value ?? "").trim();
    if(!v) return {ok:false, val:null, els:[el]};
    return {ok:true, val:v, els:[el]};
  }

  if (part.input?.kind==="integer"){
    const el = document.getElementById(id);
    const x = asNum(el?.value);
    if(!Number.isFinite(x) || !Number.isInteger(x)) return {ok:false, val:null, els:[el]};
    return {ok:true, val:x, els:[el]};
  }

  const el = document.getElementById(id);
  const x = asNum(el?.value);
  if(!Number.isFinite(x)) return {ok:false, val:null, els:[el]};
  return {ok:true, val:x, els:[el]};
}



/* -------------------- prime-factor answer parsing -------------------- */
function parsePrimeFactorString(raw){
  // Accept forms like: 2^3×3×5^2  or 2*2*2*3*25 etc
  // Reject plain "2475" with no × or ^ (not a factorisation).
  const s = raw.replace(/\s+/g,"")
               .replace(/x/gi,"×")
               .replace(/\*/g,"×")
               .replace(/\./g,"×"); // allow dot as multiply
  const hasSep = s.includes("×") || s.includes("^");
  if(!hasSep) return {ok:false, map:null};

  const parts = s.split("×").filter(Boolean);
  if(parts.length===0) return {ok:false, map:null};

  const map = {};
  for(const tok of parts){
    if(tok==="1" || tok==="+1") return {ok:false, map:null}; // disallow 1 as factor
    // exponent form p^e
    if(tok.includes("^")){
      const m = tok.match(/^(\d+)\^(\d+)$/);
      if(!m) return {ok:false, map:null};
      const p = Number(m[1]), e = Number(m[2]);
      if(!(Number.isInteger(p)&&Number.isInteger(e)&&p>=2&&e>=1)) return {ok:false, map:null};
      const f = factorise(p);
      // base should be prime ideally; but allow composite base (we factor it)
      for(const k of Object.keys(f)){
        map[k] = (map[k]||0) + f[k]*e;
      }
    } else {
      // integer factor (prime or composite)
      const v = Number(tok);
      if(!Number.isInteger(v) || v<2) return {ok:false, map:null};
      const f = factorise(v);
      for(const k of Object.keys(f)){
        map[k] = (map[k]||0) + f[k];
      }
    }
  }
  return {ok:true, map};
}

/* -------------------- marking -------------------- */
function markCurrent(){
  if(!current) return;

  clearMarks();

  let score = 0;
  let max = current.marksTotal;

  for(const part of current.parts){
    const expected = part.answer;
    const got = getUserAnswerForPart(part);
    const pm = part.marks ?? 0;

    // Drag-order marking (2 marks in the higher-order questions).
    if(expected && expected.type==="order"){
      const correct = Array.isArray(expected.value) ? expected.value : [];
      const user = Array.isArray(got.val) ? got.val : [];
      let partScore = 0;

      if(user.length === correct.length && got.els && got.els.length){
        let correctCount = 0;

        got.els.forEach((el,i)=>{
          const posOk = Boolean(got.ok) && (user[i] === correct[i]);
          if(posOk) correctCount++;
          markEl(el, posOk);
        });

        if(Boolean(got.ok) && correctCount === correct.length){
          partScore = pm;
        } else if(Boolean(got.ok) && pm>=2 && correctCount >= Math.ceil(correct.length/2)){
          partScore = 1; // partial credit
        } else {
          partScore = 0;
        }
      } else {
        if(got.els && got.els.length) got.els.forEach(el=>markEl(el,false));
        partScore = 0;
      }

      score += partScore;
      continue;
    }

    let ok = false;
    let partScore = 0;

    if(!got.ok){
      ok = false;
      partScore = 0;
    } else if(expected.type==="fraction"){
      ok = fracEq(got.val, expected.value);
    } else if(expected.type==="pair"){
      ok = close(got.val[0], expected.value[0], 1e-6) && close(got.val[1], expected.value[1], 1e-6);
    } else if(expected.type==="standardForm"){
      // require standard form: 1 ≤ A < 10 and integer n
      const A = got.val.A;
      const n = got.val.n;
      const userVal = A * (10**n);
      const targetVal = expected.value;
      ok = Number.isFinite(userVal) && Number.isFinite(A) && Number.isInteger(n) && A>=1 && A<10 &&
           close(userVal, targetVal, Math.max(1e-9, Math.abs(targetVal)*1e-8));
    } else if(expected.type==="primeFactors"){
      const parsed = parsePrimeFactorString(got.val);
      ok = parsed.ok && mapsEqual(parsed.map, expected.value);
    } else if(expected.type==="symbol"){
      ok = got.val === expected.value;
    } else if(expected.type==="time"){
      ok = String(got.val).trim() === String(expected.value).trim();
    } else {
      // number (with special rounding rule for calculator questions)
      const tol = Math.max(1e-9, Math.abs(expected.value)*1e-8);

      if(typeof got.val === "number" && Number.isFinite(got.val)){
        const exactOk = close(got.val, expected.value, tol);

        if(typeof expected.dp === "number"){
          const dp = expected.dp;
          const raw = (got.els && got.els[0]) ? String(got.els[0].value).trim() : String(got.val);
          const fmtOk = new RegExp(`^-?\d+(\.\d{${dp}})$`).test(raw);

          if(exactOk && fmtOk){
            ok = true;
            partScore = pm;
          } else if(Math.abs(got.val - expected.value) <= 1){
            ok = false;
            partScore = Math.max(0, pm - 1);
          } else {
            ok = false;
            partScore = 0;
          }
        } else {
          ok = exactOk;
        }
      } else {
        ok = false;
      }
    }

    if(partScore===0 && ok) partScore = pm;

    // Mark UI elements (green only for full marks)
    if(got.els && got.els.length){
      got.els.forEach(el=>markEl(el, ok));
    }

    score += partScore;
  }

  fb.style.display="block";
  fb.className = "feedback " + (score===max ? "good" : (score>0 ? "" : "bad"));
  fb.innerHTML = `<b>Score:</b> ${score} / ${max}`;
}




function revealCurrent(){
  if(!current) return;
  const fb = document.getElementById("fb");
  if(!fb) return;
  fb.style.display = "block";

  const formatStd = (v)=>{
    const num = Number(v);
    if(!isFinite(num)) return String(v);
    if(num===0) return "0"; // avoid 10^0
    const sign = num<0 ? "−" : "";
    const abs = Math.abs(num);
    const n = Math.floor(Math.log10(abs));
    if(n===0) return sign + fmt(abs,4); // avoid 10^0
    const A = abs / Math.pow(10,n);
    return `${sign}${fmt(A,4)} × 10<sup>${n}</sup>`;
  };

  const formatPF = (map)=>{
    const parts = Object.entries(map)
      .sort((a,b)=>Number(a[0])-Number(b[0]))
      .map(([p,e])=>{
        const ee = Number(e);
        return ee===1 ? `${p}` : `${p}<sup>${ee}</sup>`;
      });
    return parts.join(" × ");
  };

  const answers = current.parts.map(p=>{
    const ex = p.answer;
    if(!ex) return "";
    if(ex.type==="fraction"){
      return mfrac(ex.value.n, ex.value.d);
    }
    if(ex.type==="order"){
      const tok=(t)=>{const s=String(t);const m=s.match(/^(-?\d+)\s*\/\s*(\d+)$/);return m?mfrac(parseInt(m[1],10),parseInt(m[2],10)):s;};
      return ex.value.map(tok).join(", ");
    }
    if(ex.type==="pair"){
      return `(${ex.value[0]}, ${ex.value[1]})`;
    }
    if(ex.type==="primeFactors"){
      return formatPF(ex.value);
    }
    if(ex.type==="standardForm"){
      return formatStd(ex.value);
    }
    if(ex.type==="time"){
      return String(ex.value);
    }
    if(ex.type==="number" && typeof ex.dp==="number"){
      return Number(ex.value).toFixed(ex.dp);
    }
    if(p.input && p.input.kind==="money"){
      return "£" + Number(ex.value).toFixed(2);
    }
    return String(ex.value);
  });

  fb.innerHTML = `
    <div style="margin-top:10px">
      <b>Answers:</b>
      <ol style="margin:8px 0 0 18px">
        ${answers.map(a=>`<li>${a}</li>`).join("")}
      </ol>
    </div>
  `;
}




function generateNew(){
  const topic = topicSel.value;
  const marks = Number(marksSel.value);
  const paperMode = calcSel.value;

  const rng = makeRng(cryptoSeed());
  let q = buildQuestion(topic, marks, paperMode, rng);

  // Patch: N11(3) placeholder fix if needed
  if(q.topicCode==="N11" && q.marksTotal===3){
    // we generated a placeholder null; replace with a consistent y equation
    const xAns = q.parts[0].answer.value;
    const k = Math.floor(Math.random()*19)+2; // 2..20, OK for patch only
    q.parts[1].textHtml = `Now find <b>y</b>: <b>y − ${xAns} = ${k}</b>. <span class="endmark">[1]</span>`;
    q.parts[1].answer.value = xAns + k;
  }

  // Safety: ensure marks sum
  const sum = q.parts.reduce((s,p)=>s+(p.marks||0),0);
  if(sum !== q.marksTotal){
    console.warn("Marks mismatch; adjusting", {sum, expected:q.marksTotal});
    // force 1 mark each then remainder on last
    const parts = q.parts.map(p=>({...p, marks:1}));
    const remainder = q.marksTotal - parts.length;
    if(remainder>0) parts[parts.length-1].marks += remainder;
    q.parts = parts;
  }

  current = q;
  renderQuestion(q);
}

regenBtn.addEventListener("click", generateNew);
checkBtn.addEventListener("click", markCurrent);
revealBtn.addEventListener("click", revealCurrent);
topicSel.addEventListener("change", generateNew);
marksSel.addEventListener("change", generateNew);
calcSel.addEventListener("change", generateNew);

/* -------------------- init -------------------- */
initTopicDropdown();
generateNew();
</script>
</body>
</html>
